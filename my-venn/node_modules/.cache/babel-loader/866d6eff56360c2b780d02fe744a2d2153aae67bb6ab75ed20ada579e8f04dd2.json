{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-transition')) : typeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-transition'], factory) : factory(global.venn = {}, global.d3, global.d3);\n})(this, function (exports, d3Selection, d3Transition) {\n  'use strict';\n\n  var SMALL = 1e-10;\n\n  /** Returns the intersection area of a bunch of circles (where each circle\n   is an object having an x,y and radius property) */\n  function intersectionArea(circles, stats) {\n    // get all the intersection points of the circles\n    var intersectionPoints = getIntersectionPoints(circles);\n\n    // filter out points that aren't included in all the circles\n    var innerPoints = intersectionPoints.filter(function (p) {\n      return containedInCircles(p, circles);\n    });\n    var arcArea = 0,\n      polygonArea = 0,\n      arcs = [],\n      i;\n\n    // if we have intersection points that are within all the circles,\n    // then figure out the area contained by them\n    if (innerPoints.length > 1) {\n      // sort the points by angle from the center of the polygon, which lets\n      // us just iterate over points to get the edges\n      var center = getCenter(innerPoints);\n      for (i = 0; i < innerPoints.length; ++i) {\n        var p = innerPoints[i];\n        p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n      }\n      innerPoints.sort(function (a, b) {\n        return b.angle - a.angle;\n      });\n\n      // iterate over all points, get arc between the points\n      // and update the areas\n      var p2 = innerPoints[innerPoints.length - 1];\n      for (i = 0; i < innerPoints.length; ++i) {\n        var p1 = innerPoints[i];\n\n        // polygon area updates easily ...\n        polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n        // updating the arc area is a little more involved\n        var midPoint = {\n            x: (p1.x + p2.x) / 2,\n            y: (p1.y + p2.y) / 2\n          },\n          arc = null;\n        for (var j = 0; j < p1.parentIndex.length; ++j) {\n          if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n            // figure out the angle halfway between the two points\n            // on the current circle\n            var circle = circles[p1.parentIndex[j]],\n              a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n              a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n            var angleDiff = a2 - a1;\n            if (angleDiff < 0) {\n              angleDiff += 2 * Math.PI;\n            }\n\n            // and use that angle to figure out the width of the\n            // arc\n            var a = a2 - angleDiff / 2,\n              width = distance(midPoint, {\n                x: circle.x + circle.radius * Math.sin(a),\n                y: circle.y + circle.radius * Math.cos(a)\n              });\n\n            // clamp the width to the largest is can actually be\n            // (sometimes slightly overflows because of FP errors)\n            if (width > circle.radius * 2) {\n              width = circle.radius * 2;\n            }\n\n            // pick the circle whose arc has the smallest width\n            if (arc === null || arc.width > width) {\n              arc = {\n                circle: circle,\n                width: width,\n                p1: p1,\n                p2: p2\n              };\n            }\n          }\n        }\n        if (arc !== null) {\n          arcs.push(arc);\n          arcArea += circleArea(arc.circle.radius, arc.width);\n          p2 = p1;\n        }\n      }\n    } else {\n      // no intersection points, is either disjoint - or is completely\n      // overlapped. figure out which by examining the smallest circle\n      var smallest = circles[0];\n      for (i = 1; i < circles.length; ++i) {\n        if (circles[i].radius < smallest.radius) {\n          smallest = circles[i];\n        }\n      }\n\n      // make sure the smallest circle is completely contained in all\n      // the other circles\n      var disjoint = false;\n      for (i = 0; i < circles.length; ++i) {\n        if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n          disjoint = true;\n          break;\n        }\n      }\n      if (disjoint) {\n        arcArea = polygonArea = 0;\n      } else {\n        arcArea = smallest.radius * smallest.radius * Math.PI;\n        arcs.push({\n          circle: smallest,\n          p1: {\n            x: smallest.x,\n            y: smallest.y + smallest.radius\n          },\n          p2: {\n            x: smallest.x - SMALL,\n            y: smallest.y + smallest.radius\n          },\n          width: smallest.radius * 2\n        });\n      }\n    }\n    polygonArea /= 2;\n    if (stats) {\n      stats.area = arcArea + polygonArea;\n      stats.arcArea = arcArea;\n      stats.polygonArea = polygonArea;\n      stats.arcs = arcs;\n      stats.innerPoints = innerPoints;\n      stats.intersectionPoints = intersectionPoints;\n    }\n    return arcArea + polygonArea;\n  }\n\n  /** returns whether a point is contained by all of a list of circles */\n  function containedInCircles(point, circles) {\n    for (var i = 0; i < circles.length; ++i) {\n      if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /** Gets all intersection points between a bunch of circles */\n  function getIntersectionPoints(circles) {\n    var ret = [];\n    for (var i = 0; i < circles.length; ++i) {\n      for (var j = i + 1; j < circles.length; ++j) {\n        var intersect = circleCircleIntersection(circles[i], circles[j]);\n        for (var k = 0; k < intersect.length; ++k) {\n          var p = intersect[k];\n          p.parentIndex = [i, j];\n          ret.push(p);\n        }\n      }\n    }\n    return ret;\n  }\n\n  /** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\n  function circleArea(r, width) {\n    return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));\n  }\n\n  /** euclidean distance between two points */\n  function distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n  }\n\n  /** Returns the overlap area of two circles of radius r1 and r2 - that\n  have their centers separated by distance d. Simpler faster\n  circle intersection for only two circles */\n  function circleOverlap(r1, r2, d) {\n    // no overlap\n    if (d >= r1 + r2) {\n      return 0;\n    }\n\n    // completely overlapped\n    if (d <= Math.abs(r1 - r2)) {\n      return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n    }\n    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n      w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n    return circleArea(r1, w1) + circleArea(r2, w2);\n  }\n\n  /** Given two circles (containing a x/y/radius attributes),\n  returns the intersecting points if possible.\n  note: doesn't handle cases where there are infinitely many\n  intersection points (circles are equivalent):, or only one intersection point*/\n  function circleCircleIntersection(p1, p2) {\n    var d = distance(p1, p2),\n      r1 = p1.radius,\n      r2 = p2.radius;\n\n    // if to far away, or self contained - can't be done\n    if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {\n      return [];\n    }\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n      h = Math.sqrt(r1 * r1 - a * a),\n      x0 = p1.x + a * (p2.x - p1.x) / d,\n      y0 = p1.y + a * (p2.y - p1.y) / d,\n      rx = -(p2.y - p1.y) * (h / d),\n      ry = -(p2.x - p1.x) * (h / d);\n    return [{\n      x: x0 + rx,\n      y: y0 - ry\n    }, {\n      x: x0 - rx,\n      y: y0 + ry\n    }];\n  }\n\n  /** Returns the center of a bunch of points */\n  function getCenter(points) {\n    var center = {\n      x: 0,\n      y: 0\n    };\n    for (var i = 0; i < points.length; ++i) {\n      center.x += points[i].x;\n      center.y += points[i].y;\n    }\n    center.x /= points.length;\n    center.y /= points.length;\n    return center;\n  }\n\n  /** finds the zeros of a function, given two starting points (which must\n   * have opposite signs */\n  function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n      tolerance = parameters.tolerance || 1e-10,\n      fA = f(a),\n      fB = f(b),\n      delta = b - a;\n    if (fA * fB > 0) {\n      throw \"Initial bisect points must have opposite signs\";\n    }\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n    for (var i = 0; i < maxIterations; ++i) {\n      delta /= 2;\n      var mid = a + delta,\n        fMid = f(mid);\n      if (fMid * fA >= 0) {\n        a = mid;\n      }\n      if (Math.abs(delta) < tolerance || fMid === 0) {\n        return mid;\n      }\n    }\n    return a + delta;\n  }\n\n  // need some basic operations on vectors, rather than adding a dependency,\n  // just define here\n  function zeros(x) {\n    var r = new Array(x);\n    for (var i = 0; i < x; ++i) {\n      r[i] = 0;\n    }\n    return r;\n  }\n  function zerosM(x, y) {\n    return zeros(x).map(function () {\n      return zeros(y);\n    });\n  }\n  function dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n      ret += a[i] * b[i];\n    }\n    return ret;\n  }\n  function norm2(a) {\n    return Math.sqrt(dot(a, a));\n  }\n  function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n      ret[i] = value[i] * c;\n    }\n  }\n  function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n      ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n  }\n\n  /** minimizes a function using the downhill simplex method */\n  function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n      nonZeroDelta = parameters.nonZeroDelta || 1.05,\n      zeroDelta = parameters.zeroDelta || 0.001,\n      minErrorDelta = parameters.minErrorDelta || 1e-6,\n      minTolerance = parameters.minErrorDelta || 1e-5,\n      rho = parameters.rho !== undefined ? parameters.rho : 1,\n      chi = parameters.chi !== undefined ? parameters.chi : 2,\n      psi = parameters.psi !== undefined ? parameters.psi : -0.5,\n      sigma = parameters.sigma !== undefined ? parameters.sigma : 0.5,\n      maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n      simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n      var point = x0.slice();\n      point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n      simplex[i + 1] = point;\n      simplex[i + 1].fx = f(point);\n      simplex[i + 1].id = i + 1;\n    }\n    function updateSimplex(value) {\n      for (var i = 0; i < value.length; i++) {\n        simplex[N][i] = value[i];\n      }\n      simplex[N].fx = value.fx;\n    }\n    var sortOrder = function (a, b) {\n      return a.fx - b.fx;\n    };\n    var centroid = x0.slice(),\n      reflected = x0.slice(),\n      contracted = x0.slice(),\n      expanded = x0.slice();\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n      simplex.sort(sortOrder);\n      if (parameters.history) {\n        // copy the simplex (since later iterations will mutate) and\n        // sort it to have a consistent order between iterations\n        var sortedSimplex = simplex.map(function (x) {\n          var state = x.slice();\n          state.fx = x.fx;\n          state.id = x.id;\n          return state;\n        });\n        sortedSimplex.sort(function (a, b) {\n          return a.id - b.id;\n        });\n        parameters.history.push({\n          x: simplex[0].slice(),\n          fx: simplex[0].fx,\n          simplex: sortedSimplex\n        });\n      }\n      maxDiff = 0;\n      for (i = 0; i < N; ++i) {\n        maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n      }\n      if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {\n        break;\n      }\n\n      // compute the centroid of all but the worst point in the simplex\n      for (i = 0; i < N; ++i) {\n        centroid[i] = 0;\n        for (var j = 0; j < N; ++j) {\n          centroid[i] += simplex[j][i];\n        }\n        centroid[i] /= N;\n      }\n\n      // reflect the worst point past the centroid  and compute loss at reflected\n      // point\n      var worst = simplex[N];\n      weightedSum(reflected, 1 + rho, centroid, -rho, worst);\n      reflected.fx = f(reflected);\n\n      // if the reflected point is the best seen, then possibly expand\n      if (reflected.fx < simplex[0].fx) {\n        weightedSum(expanded, 1 + chi, centroid, -chi, worst);\n        expanded.fx = f(expanded);\n        if (expanded.fx < reflected.fx) {\n          updateSimplex(expanded);\n        } else {\n          updateSimplex(reflected);\n        }\n      }\n\n      // if the reflected point is worse than the second worst, we need to\n      // contract\n      else if (reflected.fx >= simplex[N - 1].fx) {\n        var shouldReduce = false;\n        if (reflected.fx > worst.fx) {\n          // do an inside contraction\n          weightedSum(contracted, 1 + psi, centroid, -psi, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < worst.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        } else {\n          // do an outside contraction\n          weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);\n          contracted.fx = f(contracted);\n          if (contracted.fx < reflected.fx) {\n            updateSimplex(contracted);\n          } else {\n            shouldReduce = true;\n          }\n        }\n        if (shouldReduce) {\n          // if we don't contract here, we're done\n          if (sigma >= 1) break;\n\n          // do a reduction\n          for (i = 1; i < simplex.length; ++i) {\n            weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n            simplex[i].fx = f(simplex[i]);\n          }\n        }\n      } else {\n        updateSimplex(reflected);\n      }\n    }\n    simplex.sort(sortOrder);\n    return {\n      fx: simplex[0].fx,\n      x: simplex[0]\n    };\n  }\n\n  /// searches along line 'pk' for a point that satifies the wolfe conditions\n  /// See 'Numerical Optimization' by Nocedal and Wright p59-60\n  /// f : objective function\n  /// pk : search direction\n  /// current: object containing current gradient/loss\n  /// next: output: contains next gradient/loss\n  /// returns a: step size taken\n  function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx,\n      phiPrime0 = dot(current.fxprime, pk),\n      phi = phi0,\n      phi_old = phi0,\n      phiPrime = phiPrime0,\n      a0 = 0;\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n    function zoom(a_lo, a_high, phi_lo) {\n      for (var iteration = 0; iteration < 16; ++iteration) {\n        a = (a_lo + a_high) / 2;\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if (phi > phi0 + c1 * a * phiPrime0 || phi >= phi_lo) {\n          a_high = a;\n        } else {\n          if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n          }\n          if (phiPrime * (a_high - a_lo) >= 0) {\n            a_high = a_lo;\n          }\n          a_lo = a;\n          phi_lo = phi;\n        }\n      }\n      return 0;\n    }\n    for (var iteration = 0; iteration < 10; ++iteration) {\n      weightedSum(next.x, 1.0, current.x, a, pk);\n      phi = next.fx = f(next.x, next.fxprime);\n      phiPrime = dot(next.fxprime, pk);\n      if (phi > phi0 + c1 * a * phiPrime0 || iteration && phi >= phi_old) {\n        return zoom(a0, a, phi_old);\n      }\n      if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n        return a;\n      }\n      if (phiPrime >= 0) {\n        return zoom(a, a0, phi);\n      }\n      phi_old = phi;\n      a0 = a;\n      a *= 2;\n    }\n    return a;\n  }\n  function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      next = {\n        x: initial.slice(),\n        fx: 0,\n        fxprime: initial.slice()\n      },\n      yk = initial.slice(),\n      pk,\n      temp,\n      a = 1,\n      maxIterations;\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime, -1);\n    for (var i = 0; i < maxIterations; ++i) {\n      a = wolfeLineSearch(f, pk, current, next, a);\n\n      // todo: history in wrong spot?\n      if (params.history) {\n        params.history.push({\n          x: current.x.slice(),\n          fx: current.fx,\n          fxprime: current.fxprime.slice(),\n          alpha: a\n        });\n      }\n      if (!a) {\n        // faiiled to find point that satifies wolfe conditions.\n        // reset direction for next iteration\n        scale(pk, current.fxprime, -1);\n      } else {\n        // update direction using Polakâ€“Ribiere CG method\n        weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n        var delta_k = dot(current.fxprime, current.fxprime),\n          beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n        weightedSum(pk, beta_k, pk, -1, next.fxprime);\n        temp = current;\n        current = next;\n        next = temp;\n      }\n      if (norm2(current.fxprime) <= 1e-5) {\n        break;\n      }\n    }\n    if (params.history) {\n      params.history.push({\n        x: current.x.slice(),\n        fx: current.fx,\n        fxprime: current.fxprime.slice(),\n        alpha: a\n      });\n    }\n    return current;\n  }\n\n  /** given a list of set objects, and their corresponding overlaps.\n  updates the (x, y, radius) attribute on each set such that their positions\n  roughly correspond to the desired overlaps */\n  function venn(areas, parameters) {\n    parameters = parameters || {};\n    parameters.maxIterations = parameters.maxIterations || 500;\n    var initialLayout = parameters.initialLayout || bestInitialLayout;\n    var loss = parameters.lossFunction || lossFunction;\n\n    // add in missing pairwise areas as having 0 size\n    areas = addMissingAreas(areas);\n\n    // initial layout is done greedily\n    var circles = initialLayout(areas, parameters);\n\n    // transform x/y coordinates to a vector to optimize\n    var initial = [],\n      setids = [],\n      setid;\n    for (setid in circles) {\n      if (circles.hasOwnProperty(setid)) {\n        initial.push(circles[setid].x);\n        initial.push(circles[setid].y);\n        setids.push(setid);\n      }\n    }\n\n    // optimize initial layout from our loss function\n    var solution = nelderMead(function (values) {\n      var current = {};\n      for (var i = 0; i < setids.length; ++i) {\n        var setid = setids[i];\n        current[setid] = {\n          x: values[2 * i],\n          y: values[2 * i + 1],\n          radius: circles[setid].radius\n          // size : circles[setid].size\n        };\n      }\n      return loss(current, areas);\n    }, initial, parameters);\n\n    // transform solution vector back to x/y points\n    var positions = solution.x;\n    for (var i = 0; i < setids.length; ++i) {\n      setid = setids[i];\n      circles[setid].x = positions[2 * i];\n      circles[setid].y = positions[2 * i + 1];\n    }\n    return circles;\n  }\n  var SMALL$1 = 1e-10;\n\n  /** Returns the distance necessary for two circles of radius r1 + r2 to\n  have the overlap area 'overlap' */\n  function distanceFromIntersectArea(r1, r2, overlap) {\n    // handle complete overlapped circles\n    if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap + SMALL$1) {\n      return Math.abs(r1 - r2);\n    }\n    return bisect(function (distance$$1) {\n      return circleOverlap(r1, r2, distance$$1) - overlap;\n    }, 0, r1 + r2);\n  }\n\n  /** Missing pair-wise intersection area data can cause problems:\n   treating as an unknown means that sets will be laid out overlapping,\n   which isn't what people expect. To reflect that we want disjoint sets\n   here, set the overlap to 0 for all missing pairwise set intersections */\n  function addMissingAreas(areas) {\n    areas = areas.slice();\n\n    // two circle intersections that aren't defined\n    var ids = [],\n      pairs = {},\n      i,\n      j,\n      a,\n      b;\n    for (i = 0; i < areas.length; ++i) {\n      var area = areas[i];\n      if (area.sets.length == 1) {\n        ids.push(area.sets[0]);\n      } else if (area.sets.length == 2) {\n        a = area.sets[0];\n        b = area.sets[1];\n        pairs[[a, b]] = true;\n        pairs[[b, a]] = true;\n      }\n    }\n    ids.sort(function (a, b) {\n      return a > b;\n    });\n    for (i = 0; i < ids.length; ++i) {\n      a = ids[i];\n      for (j = i + 1; j < ids.length; ++j) {\n        b = ids[j];\n        if (!([a, b] in pairs)) {\n          areas.push({\n            'sets': [a, b],\n            'size': 0\n          });\n        }\n      }\n    }\n    return areas;\n  }\n\n  /// Returns two matrices, one of the euclidean distances between the sets\n  /// and the other indicating if there are subset or disjoint set relationships\n  function getDistanceMatrices(areas, sets, setids) {\n    // initialize an empty distance matrix between all the points\n    var distances = zerosM(sets.length, sets.length),\n      constraints = zerosM(sets.length, sets.length);\n\n    // compute required distances between all the sets such that\n    // the areas match\n    areas.filter(function (x) {\n      return x.sets.length == 2;\n    }).map(function (current) {\n      var left = setids[current.sets[0]],\n        right = setids[current.sets[1]],\n        r1 = Math.sqrt(sets[left].size / Math.PI),\n        r2 = Math.sqrt(sets[right].size / Math.PI),\n        distance$$1 = distanceFromIntersectArea(r1, r2, current.size);\n      distances[left][right] = distances[right][left] = distance$$1;\n\n      // also update constraints to indicate if its a subset or disjoint\n      // relationship\n      var c = 0;\n      if (current.size + 1e-10 >= Math.min(sets[left].size, sets[right].size)) {\n        c = 1;\n      } else if (current.size <= 1e-10) {\n        c = -1;\n      }\n      constraints[left][right] = constraints[right][left] = c;\n    });\n    return {\n      distances: distances,\n      constraints: constraints\n    };\n  }\n\n  /// computes the gradient and loss simulatenously for our constrained MDS optimizer\n  function constrainedMDSGradient(x, fxprime, distances, constraints) {\n    var loss = 0,\n      i;\n    for (i = 0; i < fxprime.length; ++i) {\n      fxprime[i] = 0;\n    }\n    for (i = 0; i < distances.length; ++i) {\n      var xi = x[2 * i],\n        yi = x[2 * i + 1];\n      for (var j = i + 1; j < distances.length; ++j) {\n        var xj = x[2 * j],\n          yj = x[2 * j + 1],\n          dij = distances[i][j],\n          constraint = constraints[i][j];\n        var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n          distance$$1 = Math.sqrt(squaredDistance),\n          delta = squaredDistance - dij * dij;\n        if (constraint > 0 && distance$$1 <= dij || constraint < 0 && distance$$1 >= dij) {\n          continue;\n        }\n        loss += 2 * delta * delta;\n        fxprime[2 * i] += 4 * delta * (xi - xj);\n        fxprime[2 * i + 1] += 4 * delta * (yi - yj);\n        fxprime[2 * j] += 4 * delta * (xj - xi);\n        fxprime[2 * j + 1] += 4 * delta * (yj - yi);\n      }\n    }\n    return loss;\n  }\n\n  /// takes the best working variant of either constrained MDS or greedy\n  function bestInitialLayout(areas, params) {\n    var initial = greedyLayout(areas, params);\n    var loss = params.lossFunction || lossFunction;\n\n    // greedylayout is sufficient for all 2/3 circle cases. try out\n    // constrained MDS for higher order problems, take its output\n    // if it outperforms. (greedy is aesthetically better on 2/3 circles\n    // since it axis aligns)\n    if (areas.length >= 8) {\n      var constrained = constrainedMDSLayout(areas, params),\n        constrainedLoss = loss(constrained, areas),\n        greedyLoss = loss(initial, areas);\n      if (constrainedLoss + 1e-8 < greedyLoss) {\n        initial = constrained;\n      }\n    }\n    return initial;\n  }\n\n  /// use the constrained MDS variant to generate an initial layout\n  function constrainedMDSLayout(areas, params) {\n    params = params || {};\n    var restarts = params.restarts || 10;\n\n    // bidirectionally map sets to a rowid  (so we can create a matrix)\n    var sets = [],\n      setids = {},\n      i;\n    for (i = 0; i < areas.length; ++i) {\n      var area = areas[i];\n      if (area.sets.length == 1) {\n        setids[area.sets[0]] = sets.length;\n        sets.push(area);\n      }\n    }\n    var matrices = getDistanceMatrices(areas, sets, setids),\n      distances = matrices.distances,\n      constraints = matrices.constraints;\n\n    // keep distances bounded, things get messed up otherwise.\n    // TODO: proper preconditioner?\n    var norm = norm2(distances.map(norm2)) / distances.length;\n    distances = distances.map(function (row) {\n      return row.map(function (value) {\n        return value / norm;\n      });\n    });\n    var obj = function (x, fxprime) {\n      return constrainedMDSGradient(x, fxprime, distances, constraints);\n    };\n    var best, current;\n    for (i = 0; i < restarts; ++i) {\n      var initial = zeros(distances.length * 2).map(Math.random);\n      current = conjugateGradient(obj, initial, params);\n      if (!best || current.fx < best.fx) {\n        best = current;\n      }\n    }\n    var positions = best.x;\n\n    // translate rows back to (x,y,radius) coordinates\n    var circles = {};\n    for (i = 0; i < sets.length; ++i) {\n      var set = sets[i];\n      circles[set.sets[0]] = {\n        x: positions[2 * i] * norm,\n        y: positions[2 * i + 1] * norm,\n        radius: Math.sqrt(set.size / Math.PI)\n      };\n    }\n    if (params.history) {\n      for (i = 0; i < params.history.length; ++i) {\n        scale(params.history[i].x, norm);\n      }\n    }\n    return circles;\n  }\n\n  /** Lays out a Venn diagram greedily, going from most overlapped sets to\n  least overlapped, attempting to position each new set such that the\n  overlapping areas to already positioned sets are basically right */\n  function greedyLayout(areas, params) {\n    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n    // define a circle for each set\n    var circles = {},\n      setOverlaps = {},\n      set;\n    for (var i = 0; i < areas.length; ++i) {\n      var area = areas[i];\n      if (area.sets.length == 1) {\n        set = area.sets[0];\n        circles[set] = {\n          x: 1e10,\n          y: 1e10,\n          rowid: circles.length,\n          size: area.size,\n          radius: Math.sqrt(area.size / Math.PI)\n        };\n        setOverlaps[set] = [];\n      }\n    }\n    areas = areas.filter(function (a) {\n      return a.sets.length == 2;\n    });\n\n    // map each set to a list of all the other sets that overlap it\n    for (i = 0; i < areas.length; ++i) {\n      var current = areas[i];\n      var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n      var left = current.sets[0],\n        right = current.sets[1];\n\n      // completely overlapped circles shouldn't be positioned early here\n      if (current.size + SMALL$1 >= Math.min(circles[left].size, circles[right].size)) {\n        weight = 0;\n      }\n      setOverlaps[left].push({\n        set: right,\n        size: current.size,\n        weight: weight\n      });\n      setOverlaps[right].push({\n        set: left,\n        size: current.size,\n        weight: weight\n      });\n    }\n\n    // get list of most overlapped sets\n    var mostOverlapped = [];\n    for (set in setOverlaps) {\n      if (setOverlaps.hasOwnProperty(set)) {\n        var size = 0;\n        for (i = 0; i < setOverlaps[set].length; ++i) {\n          size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n        }\n        mostOverlapped.push({\n          set: set,\n          size: size\n        });\n      }\n    }\n\n    // sort by size desc\n    function sortOrder(a, b) {\n      return b.size - a.size;\n    }\n    mostOverlapped.sort(sortOrder);\n\n    // keep track of what sets have been laid out\n    var positioned = {};\n    function isPositioned(element) {\n      return element.set in positioned;\n    }\n\n    // adds a point to the output\n    function positionSet(point, index) {\n      circles[index].x = point.x;\n      circles[index].y = point.y;\n      positioned[index] = true;\n    }\n\n    // add most overlapped set at (0,0)\n    positionSet({\n      x: 0,\n      y: 0\n    }, mostOverlapped[0].set);\n\n    // get distances between all points. TODO, necessary?\n    // answer: probably not\n    // var distances = venn.getDistanceMatrices(circles, areas).distances;\n    for (i = 1; i < mostOverlapped.length; ++i) {\n      var setIndex = mostOverlapped[i].set,\n        overlap = setOverlaps[setIndex].filter(isPositioned);\n      set = circles[setIndex];\n      overlap.sort(sortOrder);\n      if (overlap.length === 0) {\n        // this shouldn't happen anymore with addMissingAreas\n        throw \"ERROR: missing pairwise overlap information\";\n      }\n      var points = [];\n      for (var j = 0; j < overlap.length; ++j) {\n        // get appropriate distance from most overlapped already added set\n        var p1 = circles[overlap[j].set],\n          d1 = distanceFromIntersectArea(set.radius, p1.radius, overlap[j].size);\n\n        // sample positions at 90 degrees for maximum aesthetics\n        points.push({\n          x: p1.x + d1,\n          y: p1.y\n        });\n        points.push({\n          x: p1.x - d1,\n          y: p1.y\n        });\n        points.push({\n          y: p1.y + d1,\n          x: p1.x\n        });\n        points.push({\n          y: p1.y - d1,\n          x: p1.x\n        });\n\n        // if we have at least 2 overlaps, then figure out where the\n        // set should be positioned analytically and try those too\n        for (var k = j + 1; k < overlap.length; ++k) {\n          var p2 = circles[overlap[k].set],\n            d2 = distanceFromIntersectArea(set.radius, p2.radius, overlap[k].size);\n          var extraPoints = circleCircleIntersection({\n            x: p1.x,\n            y: p1.y,\n            radius: d1\n          }, {\n            x: p2.x,\n            y: p2.y,\n            radius: d2\n          });\n          for (var l = 0; l < extraPoints.length; ++l) {\n            points.push(extraPoints[l]);\n          }\n        }\n      }\n\n      // we have some candidate positions for the set, examine loss\n      // at each position to figure out where to put it at\n      var bestLoss = 1e50,\n        bestPoint = points[0];\n      for (j = 0; j < points.length; ++j) {\n        circles[setIndex].x = points[j].x;\n        circles[setIndex].y = points[j].y;\n        var localLoss = loss(circles, areas);\n        if (localLoss < bestLoss) {\n          bestLoss = localLoss;\n          bestPoint = points[j];\n        }\n      }\n      positionSet(bestPoint, setIndex);\n    }\n    return circles;\n  }\n\n  /** Given a bunch of sets, and the desired overlaps between these sets - computes\n  the distance from the actual overlaps to the desired overlaps. Note that\n  this method ignores overlaps of more than 2 circles */\n  function lossFunction(sets, overlaps) {\n    var output = 0;\n    function getCircles(indices) {\n      return indices.map(function (i) {\n        return sets[i];\n      });\n    }\n    for (var i = 0; i < overlaps.length; ++i) {\n      var area = overlaps[i],\n        overlap;\n      if (area.sets.length == 1) {\n        continue;\n      } else if (area.sets.length == 2) {\n        var left = sets[area.sets[0]],\n          right = sets[area.sets[1]];\n        overlap = circleOverlap(left.radius, right.radius, distance(left, right));\n      } else {\n        overlap = intersectionArea(getCircles(area.sets));\n      }\n      var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n      output += weight * (overlap - area.size) * (overlap - area.size);\n    }\n    return output;\n  }\n\n  // orientates a bunch of circles to point in orientation\n  function orientateCircles(circles, orientation, orientationOrder) {\n    if (orientationOrder === null) {\n      circles.sort(function (a, b) {\n        return b.radius - a.radius;\n      });\n    } else {\n      circles.sort(orientationOrder);\n    }\n    var i;\n    // shift circles so largest circle is at (0, 0)\n    if (circles.length > 0) {\n      var largestX = circles[0].x,\n        largestY = circles[0].y;\n      for (i = 0; i < circles.length; ++i) {\n        circles[i].x -= largestX;\n        circles[i].y -= largestY;\n      }\n    }\n    if (circles.length == 2) {\n      // if the second circle is a subset of the first, arrange so that\n      // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n      var dist = distance(circles[0], circles[1]);\n      if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n        circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n        circles[1].y = circles[0].y;\n      }\n    }\n\n    // rotate circles so that second largest is at an angle of 'orientation'\n    // from largest\n    if (circles.length > 1) {\n      var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n        c = Math.cos(rotation),\n        s = Math.sin(rotation),\n        x,\n        y;\n      for (i = 0; i < circles.length; ++i) {\n        x = circles[i].x;\n        y = circles[i].y;\n        circles[i].x = c * x - s * y;\n        circles[i].y = s * x + c * y;\n      }\n    }\n\n    // mirror solution if third solution is above plane specified by\n    // first two circles\n    if (circles.length > 2) {\n      var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n      while (angle < 0) {\n        angle += 2 * Math.PI;\n      }\n      while (angle > 2 * Math.PI) {\n        angle -= 2 * Math.PI;\n      }\n      if (angle > Math.PI) {\n        var slope = circles[1].y / (1e-10 + circles[1].x);\n        for (i = 0; i < circles.length; ++i) {\n          var d = (circles[i].x + slope * circles[i].y) / (1 + slope * slope);\n          circles[i].x = 2 * d - circles[i].x;\n          circles[i].y = 2 * d * slope - circles[i].y;\n        }\n      }\n    }\n  }\n  function disjointCluster(circles) {\n    // union-find clustering to get disjoint sets\n    circles.map(function (circle) {\n      circle.parent = circle;\n    });\n\n    // path compression step in union find\n    function find(circle) {\n      if (circle.parent !== circle) {\n        circle.parent = find(circle.parent);\n      }\n      return circle.parent;\n    }\n    function union(x, y) {\n      var xRoot = find(x),\n        yRoot = find(y);\n      xRoot.parent = yRoot;\n    }\n\n    // get the union of all overlapping sets\n    for (var i = 0; i < circles.length; ++i) {\n      for (var j = i + 1; j < circles.length; ++j) {\n        var maxDistance = circles[i].radius + circles[j].radius;\n        if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n          union(circles[j], circles[i]);\n        }\n      }\n    }\n\n    // find all the disjoint clusters and group them together\n    var disjointClusters = {},\n      setid;\n    for (i = 0; i < circles.length; ++i) {\n      setid = find(circles[i]).parent.setid;\n      if (!(setid in disjointClusters)) {\n        disjointClusters[setid] = [];\n      }\n      disjointClusters[setid].push(circles[i]);\n    }\n\n    // cleanup bookkeeping\n    circles.map(function (circle) {\n      delete circle.parent;\n    });\n\n    // return in more usable form\n    var ret = [];\n    for (setid in disjointClusters) {\n      if (disjointClusters.hasOwnProperty(setid)) {\n        ret.push(disjointClusters[setid]);\n      }\n    }\n    return ret;\n  }\n  function getBoundingBox(circles) {\n    var minMax = function (d) {\n      var hi = Math.max.apply(null, circles.map(function (c) {\n          return c[d] + c.radius;\n        })),\n        lo = Math.min.apply(null, circles.map(function (c) {\n          return c[d] - c.radius;\n        }));\n      return {\n        max: hi,\n        min: lo\n      };\n    };\n    return {\n      xRange: minMax('x'),\n      yRange: minMax('y')\n    };\n  }\n  function normalizeSolution(solution, orientation, orientationOrder) {\n    if (orientation === null) {\n      orientation = Math.PI / 2;\n    }\n\n    // work with a list instead of a dictionary, and take a copy so we\n    // don't mutate input\n    var circles = [],\n      i,\n      setid;\n    for (setid in solution) {\n      if (solution.hasOwnProperty(setid)) {\n        var previous = solution[setid];\n        circles.push({\n          x: previous.x,\n          y: previous.y,\n          radius: previous.radius,\n          setid: setid\n        });\n      }\n    }\n\n    // get all the disjoint clusters\n    var clusters = disjointCluster(circles);\n\n    // orientate all disjoint sets, get sizes\n    for (i = 0; i < clusters.length; ++i) {\n      orientateCircles(clusters[i], orientation, orientationOrder);\n      var bounds = getBoundingBox(clusters[i]);\n      clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n      clusters[i].bounds = bounds;\n    }\n    clusters.sort(function (a, b) {\n      return b.size - a.size;\n    });\n\n    // orientate the largest at 0,0, and get the bounds\n    circles = clusters[0];\n    var returnBounds = circles.bounds;\n    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min) / 50;\n    function addCluster(cluster, right, bottom) {\n      if (!cluster) return;\n      var bounds = cluster.bounds,\n        xOffset,\n        yOffset,\n        centreing;\n      if (right) {\n        xOffset = returnBounds.xRange.max - bounds.xRange.min + spacing;\n      } else {\n        xOffset = returnBounds.xRange.max - bounds.xRange.max;\n        centreing = (bounds.xRange.max - bounds.xRange.min) / 2 - (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n        if (centreing < 0) xOffset += centreing;\n      }\n      if (bottom) {\n        yOffset = returnBounds.yRange.max - bounds.yRange.min + spacing;\n      } else {\n        yOffset = returnBounds.yRange.max - bounds.yRange.max;\n        centreing = (bounds.yRange.max - bounds.yRange.min) / 2 - (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n        if (centreing < 0) yOffset += centreing;\n      }\n      for (var j = 0; j < cluster.length; ++j) {\n        cluster[j].x += xOffset;\n        cluster[j].y += yOffset;\n        circles.push(cluster[j]);\n      }\n    }\n    var index = 1;\n    while (index < clusters.length) {\n      addCluster(clusters[index], true, false);\n      addCluster(clusters[index + 1], false, true);\n      addCluster(clusters[index + 2], true, true);\n      index += 3;\n\n      // have one cluster (in top left). lay out next three relative\n      // to it in a grid\n      returnBounds = getBoundingBox(circles);\n    }\n\n    // convert back to solution form\n    var ret = {};\n    for (i = 0; i < circles.length; ++i) {\n      ret[circles[i].setid] = circles[i];\n    }\n    return ret;\n  }\n\n  /** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\n  a rectangle of width/height - with padding around the borders. also\n  centers the diagram in the available space at the same time */\n  function scaleSolution(solution, width, height, padding) {\n    var circles = [],\n      setids = [];\n    for (var setid in solution) {\n      if (solution.hasOwnProperty(setid)) {\n        setids.push(setid);\n        circles.push(solution[setid]);\n      }\n    }\n    width -= 2 * padding;\n    height -= 2 * padding;\n    var bounds = getBoundingBox(circles),\n      xRange = bounds.xRange,\n      yRange = bounds.yRange;\n    if (xRange.max == xRange.min || yRange.max == yRange.min) {\n      console.log(\"not scaling solution: zero size detected\");\n      return solution;\n    }\n    var xScaling = width / (xRange.max - xRange.min),\n      yScaling = height / (yRange.max - yRange.min),\n      scaling = Math.min(yScaling, xScaling),\n      // while we're at it, center the diagram too\n      xOffset = (width - (xRange.max - xRange.min) * scaling) / 2,\n      yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n    var scaled = {};\n    for (var i = 0; i < circles.length; ++i) {\n      var circle = circles[i];\n      scaled[setids[i]] = {\n        radius: scaling * circle.radius,\n        x: padding + xOffset + (circle.x - xRange.min) * scaling,\n        y: padding + yOffset + (circle.y - yRange.min) * scaling\n      };\n    }\n    return scaled;\n  }\n\n  /*global console:true*/\n\n  function VennDiagram() {\n    var width = 600,\n      height = 350,\n      padding = 15,\n      duration = 1000,\n      orientation = Math.PI / 2,\n      normalize = true,\n      wrap = true,\n      styled = true,\n      fontSize = null,\n      orientationOrder = null,\n      // mimic the behaviour of d3.scale.category10 from the previous\n      // version of d3\n      colourMap = {},\n      // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n      // since we can support older versions of d3 as long as we don't force this,\n      // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n      colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n      colourIndex = 0,\n      colours = function (key) {\n        if (key in colourMap) {\n          return colourMap[key];\n        }\n        var ret = colourMap[key] = colourScheme[colourIndex];\n        colourIndex += 1;\n        if (colourIndex >= colourScheme.length) {\n          colourIndex = 0;\n        }\n        return ret;\n      },\n      layoutFunction = venn,\n      loss = lossFunction;\n    function chart(selection) {\n      var data = selection.datum();\n\n      // handle 0-sized sets by removing from input\n      var toremove = {};\n      data.forEach(function (datum) {\n        if (datum.size == 0 && datum.sets.length == 1) {\n          toremove[datum.sets[0]] = 1;\n        }\n      });\n      data = data.filter(function (datum) {\n        return !datum.sets.some(function (set) {\n          return set in toremove;\n        });\n      });\n      var circles = {};\n      var textCentres = {};\n      if (data.length > 0) {\n        var solution = layoutFunction(data, {\n          lossFunction: loss\n        });\n        if (normalize) {\n          solution = normalizeSolution(solution, orientation, orientationOrder);\n        }\n        circles = scaleSolution(solution, width, height, padding);\n        textCentres = computeTextCentres(circles, data);\n      }\n\n      // Figure out the current label for each set. These can change\n      // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n      var labels = {};\n      data.forEach(function (datum) {\n        if (datum.label) {\n          labels[datum.sets] = datum.label;\n        }\n      });\n      function label(d) {\n        if (d.sets in labels) {\n          return labels[d.sets];\n        }\n        if (d.sets.length == 1) {\n          return '' + d.sets[0];\n        }\n      }\n\n      // create svg if not already existing\n      selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n      var svg = selection.select(\"svg\").attr(\"width\", width).attr(\"height\", height);\n\n      // to properly transition intersection areas, we need the\n      // previous circles locations. load from elements\n      var previous = {},\n        hasPrevious = false;\n      svg.selectAll(\".venn-area path\").each(function (d) {\n        var path = d3Selection.select(this).attr(\"d\");\n        if (d.sets.length == 1 && path) {\n          hasPrevious = true;\n          previous[d.sets[0]] = circleFromPath(path);\n        }\n      });\n\n      // interpolate intersection area paths between previous and\n      // current paths\n      var pathTween = function (d) {\n        return function (t) {\n          var c = d.sets.map(function (set) {\n            var start = previous[set],\n              end = circles[set];\n            if (!start) {\n              start = {\n                x: width / 2,\n                y: height / 2,\n                radius: 1\n              };\n            }\n            if (!end) {\n              end = {\n                x: width / 2,\n                y: height / 2,\n                radius: 1\n              };\n            }\n            return {\n              'x': start.x * (1 - t) + end.x * t,\n              'y': start.y * (1 - t) + end.y * t,\n              'radius': start.radius * (1 - t) + end.radius * t\n            };\n          });\n          return intersectionAreaPath(c);\n        };\n      };\n\n      // update data, joining on the set ids\n      var nodes = svg.selectAll(\".venn-area\").data(data, function (d) {\n        return d.sets;\n      });\n\n      // create new nodes\n      var enter = nodes.enter().append('g').attr(\"class\", function (d) {\n        return \"venn-area venn-\" + (d.sets.length == 1 ? \"circle\" : \"intersection\");\n      }).attr(\"data-venn-sets\", function (d) {\n        return d.sets.join(\"_\");\n      });\n      var enterPath = enter.append(\"path\"),\n        enterText = enter.append(\"text\").attr(\"class\", \"label\").text(function (d) {\n          return label(d);\n        }).attr(\"text-anchor\", \"middle\").attr(\"dy\", \".35em\").attr(\"x\", width / 2).attr(\"y\", height / 2);\n\n      // apply minimal style if wanted\n      if (styled) {\n        enterPath.style(\"fill-opacity\", \"0\").filter(function (d) {\n          return d.sets.length == 1;\n        }).style(\"fill\", function (d) {\n          return colours(d.sets);\n        }).style(\"fill-opacity\", \".25\");\n        enterText.style(\"fill\", function (d) {\n          return d.sets.length == 1 ? colours(d.sets) : \"#444\";\n        });\n      }\n\n      // update existing, using pathTween if necessary\n      var update = selection;\n      if (hasPrevious) {\n        update = selection.transition(\"venn\").duration(duration);\n        update.selectAll(\"path\").attrTween(\"d\", pathTween);\n      } else {\n        update.selectAll(\"path\").attr(\"d\", function (d) {\n          return intersectionAreaPath(d.sets.map(function (set) {\n            return circles[set];\n          }));\n        });\n      }\n      var updateText = update.selectAll(\"text\").filter(function (d) {\n        return d.sets in textCentres;\n      }).text(function (d) {\n        return label(d);\n      }).attr(\"x\", function (d) {\n        return Math.floor(textCentres[d.sets].x);\n      }).attr(\"y\", function (d) {\n        return Math.floor(textCentres[d.sets].y);\n      });\n      if (wrap) {\n        if (hasPrevious) {\n          // d3 4.0 uses 'on' for events on transitions,\n          // but d3 3.0 used 'each' instead. switch appropiately\n          if ('on' in updateText) {\n            updateText.on(\"end\", wrapText(circles, label));\n          } else {\n            updateText.each(\"end\", wrapText(circles, label));\n          }\n        } else {\n          updateText.each(wrapText(circles, label));\n        }\n      }\n\n      // remove old\n      var exit = nodes.exit().transition('venn').duration(duration).remove();\n      exit.selectAll(\"path\").attrTween(\"d\", pathTween);\n      var exitText = exit.selectAll(\"text\").attr(\"x\", width / 2).attr(\"y\", height / 2);\n\n      // if we've been passed a fontSize explicitly, use it to\n      // transition\n      if (fontSize !== null) {\n        enterText.style(\"font-size\", \"0px\");\n        updateText.style(\"font-size\", fontSize);\n        exitText.style(\"font-size\", \"0px\");\n      }\n      return {\n        'circles': circles,\n        'textCentres': textCentres,\n        'nodes': nodes,\n        'enter': enter,\n        'update': update,\n        'exit': exit\n      };\n    }\n    chart.wrap = function (_) {\n      if (!arguments.length) return wrap;\n      wrap = _;\n      return chart;\n    };\n    chart.width = function (_) {\n      if (!arguments.length) return width;\n      width = _;\n      return chart;\n    };\n    chart.height = function (_) {\n      if (!arguments.length) return height;\n      height = _;\n      return chart;\n    };\n    chart.padding = function (_) {\n      if (!arguments.length) return padding;\n      padding = _;\n      return chart;\n    };\n    chart.colours = function (_) {\n      if (!arguments.length) return colours;\n      colours = _;\n      return chart;\n    };\n    chart.fontSize = function (_) {\n      if (!arguments.length) return fontSize;\n      fontSize = _;\n      return chart;\n    };\n    chart.duration = function (_) {\n      if (!arguments.length) return duration;\n      duration = _;\n      return chart;\n    };\n    chart.layoutFunction = function (_) {\n      if (!arguments.length) return layoutFunction;\n      layoutFunction = _;\n      return chart;\n    };\n    chart.normalize = function (_) {\n      if (!arguments.length) return normalize;\n      normalize = _;\n      return chart;\n    };\n    chart.styled = function (_) {\n      if (!arguments.length) return styled;\n      styled = _;\n      return chart;\n    };\n    chart.orientation = function (_) {\n      if (!arguments.length) return orientation;\n      orientation = _;\n      return chart;\n    };\n    chart.orientationOrder = function (_) {\n      if (!arguments.length) return orientationOrder;\n      orientationOrder = _;\n      return chart;\n    };\n    chart.lossFunction = function (_) {\n      if (!arguments.length) return loss;\n      loss = _;\n      return chart;\n    };\n    return chart;\n  }\n  // sometimes text doesn't fit inside the circle, if thats the case lets wrap\n  // the text here such that it fits\n  // todo: looks like this might be merged into d3 (\n  // https://github.com/mbostock/d3/issues/1642),\n  // also worth checking out is\n  // http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n  // this seems to be one of those things that should be easy but isn't\n  function wrapText(circles, labeller) {\n    return function () {\n      var text = d3Selection.select(this),\n        data = text.datum(),\n        width = circles[data.sets[0]].radius || 50,\n        label = labeller(data) || '';\n      var words = label.split(/\\s+/).reverse(),\n        maxLines = 3,\n        minChars = (label.length + words.length) / maxLines,\n        word = words.pop(),\n        line = [word],\n        joined,\n        lineNumber = 0,\n        lineHeight = 1.1,\n        // ems\n        tspan = text.text(null).append(\"tspan\").text(word);\n      while (true) {\n        word = words.pop();\n        if (!word) break;\n        line.push(word);\n        joined = line.join(\" \");\n        tspan.text(joined);\n        if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n          line.pop();\n          tspan.text(line.join(\" \"));\n          line = [word];\n          tspan = text.append(\"tspan\").text(word);\n          lineNumber++;\n        }\n      }\n      var initial = 0.35 - lineNumber * lineHeight / 2,\n        x = text.attr(\"x\"),\n        y = text.attr(\"y\");\n      text.selectAll(\"tspan\").attr(\"x\", x).attr(\"y\", y).attr(\"dy\", function (d, i) {\n        return initial + i * lineHeight + \"em\";\n      });\n    };\n  }\n  function circleMargin(current, interior, exterior) {\n    var margin = interior[0].radius - distance(interior[0], current),\n      i,\n      m;\n    for (i = 1; i < interior.length; ++i) {\n      m = interior[i].radius - distance(interior[i], current);\n      if (m <= margin) {\n        margin = m;\n      }\n    }\n    for (i = 0; i < exterior.length; ++i) {\n      m = distance(exterior[i], current) - exterior[i].radius;\n      if (m <= margin) {\n        margin = m;\n      }\n    }\n    return margin;\n  }\n\n  // compute the center of some circles by maximizing the margin of\n  // the center point relative to the circles (interior) after subtracting\n  // nearby circles (exterior)\n  function computeTextCentre(interior, exterior) {\n    // get an initial estimate by sampling around the interior circles\n    // and taking the point with the biggest margin\n    var points = [],\n      i;\n    for (i = 0; i < interior.length; ++i) {\n      var c = interior[i];\n      points.push({\n        x: c.x,\n        y: c.y\n      });\n      points.push({\n        x: c.x + c.radius / 2,\n        y: c.y\n      });\n      points.push({\n        x: c.x - c.radius / 2,\n        y: c.y\n      });\n      points.push({\n        x: c.x,\n        y: c.y + c.radius / 2\n      });\n      points.push({\n        x: c.x,\n        y: c.y - c.radius / 2\n      });\n    }\n    var initial = points[0],\n      margin = circleMargin(points[0], interior, exterior);\n    for (i = 1; i < points.length; ++i) {\n      var m = circleMargin(points[i], interior, exterior);\n      if (m >= margin) {\n        initial = points[i];\n        margin = m;\n      }\n    }\n\n    // maximize the margin numerically\n    var solution = nelderMead(function (p) {\n      return -1 * circleMargin({\n        x: p[0],\n        y: p[1]\n      }, interior, exterior);\n    }, [initial.x, initial.y], {\n      maxIterations: 500,\n      minErrorDelta: 1e-10\n    }).x;\n    var ret = {\n      x: solution[0],\n      y: solution[1]\n    };\n\n    // check solution, fallback as needed (happens if fully overlapped\n    // etc)\n    var valid = true;\n    for (i = 0; i < interior.length; ++i) {\n      if (distance(ret, interior[i]) > interior[i].radius) {\n        valid = false;\n        break;\n      }\n    }\n    for (i = 0; i < exterior.length; ++i) {\n      if (distance(ret, exterior[i]) < exterior[i].radius) {\n        valid = false;\n        break;\n      }\n    }\n    if (!valid) {\n      if (interior.length == 1) {\n        ret = {\n          x: interior[0].x,\n          y: interior[0].y\n        };\n      } else {\n        var areaStats = {};\n        intersectionArea(interior, areaStats);\n        if (areaStats.arcs.length === 0) {\n          ret = {\n            'x': 0,\n            'y': -1000,\n            disjoint: true\n          };\n        } else if (areaStats.arcs.length == 1) {\n          ret = {\n            'x': areaStats.arcs[0].circle.x,\n            'y': areaStats.arcs[0].circle.y\n          };\n        } else if (exterior.length) {\n          // try again without other circles\n          ret = computeTextCentre(interior, []);\n        } else {\n          // take average of all the points in the intersection\n          // polygon. this should basically never happen\n          // and has some issues:\n          // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n          ret = getCenter(areaStats.arcs.map(function (a) {\n            return a.p1;\n          }));\n        }\n      }\n    }\n    return ret;\n  }\n\n  // given a dictionary of {setid : circle}, returns\n  // a dictionary of setid to list of circles that completely overlap it\n  function getOverlappingCircles(circles) {\n    var ret = {},\n      circleids = [];\n    for (var circleid in circles) {\n      circleids.push(circleid);\n      ret[circleid] = [];\n    }\n    for (var i = 0; i < circleids.length; i++) {\n      var a = circles[circleids[i]];\n      for (var j = i + 1; j < circleids.length; ++j) {\n        var b = circles[circleids[j]],\n          d = distance(a, b);\n        if (d + b.radius <= a.radius + 1e-10) {\n          ret[circleids[j]].push(circleids[i]);\n        } else if (d + a.radius <= b.radius + 1e-10) {\n          ret[circleids[i]].push(circleids[j]);\n        }\n      }\n    }\n    return ret;\n  }\n  function computeTextCentres(circles, areas) {\n    var ret = {},\n      overlapped = getOverlappingCircles(circles);\n    for (var i = 0; i < areas.length; ++i) {\n      var area = areas[i].sets,\n        areaids = {},\n        exclude = {};\n      for (var j = 0; j < area.length; ++j) {\n        areaids[area[j]] = true;\n        var overlaps = overlapped[area[j]];\n        // keep track of any circles that overlap this area,\n        // and don't consider for purposes of computing the text\n        // centre\n        for (var k = 0; k < overlaps.length; ++k) {\n          exclude[overlaps[k]] = true;\n        }\n      }\n      var interior = [],\n        exterior = [];\n      for (var setid in circles) {\n        if (setid in areaids) {\n          interior.push(circles[setid]);\n        } else if (!(setid in exclude)) {\n          exterior.push(circles[setid]);\n        }\n      }\n      var centre = computeTextCentre(interior, exterior);\n      ret[area] = centre;\n      if (centre.disjoint && areas[i].size > 0) {\n        console.log(\"WARNING: area \" + area + \" not represented on screen\");\n      }\n    }\n    return ret;\n  }\n\n  // sorts all areas in the venn diagram, so that\n  // a particular area is on top (relativeTo) - and\n  // all other areas are so that the smallest areas are on top\n  function sortAreas(div, relativeTo) {\n    // figure out sets that are completly overlapped by relativeTo\n    var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n    var exclude = {};\n    for (var i = 0; i < relativeTo.sets.length; ++i) {\n      var check = relativeTo.sets[i];\n      for (var setid in overlaps) {\n        var overlap = overlaps[setid];\n        for (var j = 0; j < overlap.length; ++j) {\n          if (overlap[j] == check) {\n            exclude[setid] = true;\n            break;\n          }\n        }\n      }\n    }\n\n    // checks that all sets are in exclude;\n    function shouldExclude(sets) {\n      for (var i = 0; i < sets.length; ++i) {\n        if (!(sets[i] in exclude)) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    // need to sort div's so that Z order is correct\n    div.selectAll(\"g\").sort(function (a, b) {\n      // highest order set intersections first\n      if (a.sets.length != b.sets.length) {\n        return a.sets.length - b.sets.length;\n      }\n      if (a == relativeTo) {\n        return shouldExclude(b.sets) ? -1 : 1;\n      }\n      if (b == relativeTo) {\n        return shouldExclude(a.sets) ? 1 : -1;\n      }\n\n      // finally by size\n      return b.size - a.size;\n    });\n  }\n  function circlePath(x, y, r) {\n    var ret = [];\n    ret.push(\"\\nM\", x, y);\n    ret.push(\"\\nm\", -r, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, r * 2, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, -r * 2, 0);\n    return ret.join(\" \");\n  }\n\n  // inverse of the circlePath function, returns a circle object from an svg path\n  function circleFromPath(path) {\n    var tokens = path.split(' ');\n    return {\n      'x': parseFloat(tokens[1]),\n      'y': parseFloat(tokens[2]),\n      'radius': -parseFloat(tokens[4])\n    };\n  }\n\n  /** returns a svg path of the intersection area of a bunch of circles */\n  function intersectionAreaPath(circles) {\n    var stats = {};\n    intersectionArea(circles, stats);\n    var arcs = stats.arcs;\n    if (arcs.length === 0) {\n      return \"M 0 0\";\n    } else if (arcs.length == 1) {\n      var circle = arcs[0].circle;\n      return circlePath(circle.x, circle.y, circle.radius);\n    } else {\n      // draw path around arcs\n      var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n      for (var i = 0; i < arcs.length; ++i) {\n        var arc = arcs[i],\n          r = arc.circle.radius,\n          wide = arc.width > r;\n        ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1, arc.p1.x, arc.p1.y);\n      }\n      return ret.join(\" \");\n    }\n  }\n  exports.intersectionArea = intersectionArea;\n  exports.circleCircleIntersection = circleCircleIntersection;\n  exports.circleOverlap = circleOverlap;\n  exports.circleArea = circleArea;\n  exports.distance = distance;\n  exports.venn = venn;\n  exports.greedyLayout = greedyLayout;\n  exports.scaleSolution = scaleSolution;\n  exports.normalizeSolution = normalizeSolution;\n  exports.bestInitialLayout = bestInitialLayout;\n  exports.lossFunction = lossFunction;\n  exports.disjointCluster = disjointCluster;\n  exports.distanceFromIntersectArea = distanceFromIntersectArea;\n  exports.VennDiagram = VennDiagram;\n  exports.wrapText = wrapText;\n  exports.computeTextCentres = computeTextCentres;\n  exports.computeTextCentre = computeTextCentre;\n  exports.sortAreas = sortAreas;\n  exports.circlePath = circlePath;\n  exports.circleFromPath = circleFromPath;\n  exports.intersectionAreaPath = intersectionAreaPath;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});","map":{"version":3,"names":["global","factory","exports","module","require","define","amd","venn","d3","d3Selection","d3Transition","SMALL","intersectionArea","circles","stats","intersectionPoints","getIntersectionPoints","innerPoints","filter","p","containedInCircles","arcArea","polygonArea","arcs","i","length","center","getCenter","angle","Math","atan2","x","y","sort","a","b","p2","p1","midPoint","arc","j","parentIndex","indexOf","circle","a1","a2","angleDiff","PI","width","distance","radius","sin","cos","push","circleArea","smallest","disjoint","abs","area","point","ret","intersect","circleCircleIntersection","k","r","acos","sqrt","circleOverlap","r1","r2","d","min","w1","w2","h","x0","y0","rx","ry","points","bisect","f","parameters","maxIterations","tolerance","fA","fB","delta","mid","fMid","zeros","Array","zerosM","map","dot","norm2","scale","value","c","weightedSum","v1","v2","nelderMead","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","maxDiff","N","simplex","fx","id","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","history","sortedSimplex","state","max","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","yk","temp","alpha","delta_k","beta_k","areas","initialLayout","bestInitialLayout","loss","lossFunction","addMissingAreas","setids","setid","hasOwnProperty","solution","values","positions","SMALL$1","distanceFromIntersectArea","overlap","distance$$1","ids","pairs","sets","getDistanceMatrices","distances","constraints","left","right","size","constrainedMDSGradient","xi","yi","xj","yj","dij","constraint","squaredDistance","greedyLayout","constrained","constrainedMDSLayout","constrainedLoss","greedyLoss","restarts","matrices","norm","row","obj","best","random","set","setOverlaps","rowid","weight","mostOverlapped","positioned","isPositioned","element","positionSet","index","setIndex","d1","d2","extraPoints","l","bestLoss","bestPoint","localLoss","overlaps","output","getCircles","indices","orientateCircles","orientation","orientationOrder","largestX","largestY","dist","rotation","s","slope","disjointCluster","parent","find","union","xRoot","yRoot","maxDistance","disjointClusters","getBoundingBox","minMax","hi","apply","lo","xRange","yRange","normalizeSolution","previous","clusters","bounds","returnBounds","spacing","addCluster","cluster","bottom","xOffset","yOffset","centreing","scaleSolution","height","padding","console","log","xScaling","yScaling","scaling","scaled","VennDiagram","duration","normalize","wrap","styled","fontSize","colourMap","colourScheme","colourIndex","colours","key","layoutFunction","chart","selection","data","datum","toremove","forEach","some","textCentres","computeTextCentres","labels","label","selectAll","enter","append","svg","select","attr","hasPrevious","each","path","circleFromPath","pathTween","t","start","end","intersectionAreaPath","nodes","join","enterPath","enterText","text","style","update","transition","attrTween","updateText","floor","on","wrapText","exit","remove","exitText","_","arguments","labeller","words","split","reverse","maxLines","minChars","word","pop","line","joined","lineNumber","lineHeight","tspan","node","getComputedTextLength","circleMargin","interior","exterior","margin","m","computeTextCentre","valid","areaStats","getOverlappingCircles","circleids","circleid","overlapped","areaids","exclude","centre","sortAreas","div","relativeTo","check","shouldExclude","circlePath","tokens","parseFloat","wide","Object","defineProperty"],"sources":["/Users/nikhilsingh/Desktop/my-venn/node_modules/venn.js/build/venn.js"],"sourcesContent":["(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('d3-selection'), require('d3-transition')) :\n\ttypeof define === 'function' && define.amd ? define(['exports', 'd3-selection', 'd3-transition'], factory) :\n\t(factory((global.venn = {}),global.d3,global.d3));\n}(this, (function (exports,d3Selection,d3Transition) { 'use strict';\n\nvar SMALL = 1e-10;\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nfunction intersectionArea(circles, stats) {\n    // get all the intersection points of the circles\n    var intersectionPoints = getIntersectionPoints(circles);\n\n    // filter out points that aren't included in all the circles\n    var innerPoints = intersectionPoints.filter(function (p) {\n        return containedInCircles(p, circles);\n    });\n\n    var arcArea = 0, polygonArea = 0, arcs = [], i;\n\n    // if we have intersection points that are within all the circles,\n    // then figure out the area contained by them\n    if (innerPoints.length > 1) {\n        // sort the points by angle from the center of the polygon, which lets\n        // us just iterate over points to get the edges\n        var center = getCenter(innerPoints);\n        for (i = 0; i < innerPoints.length; ++i ) {\n            var p = innerPoints[i];\n            p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n        }\n        innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\n        // iterate over all points, get arc between the points\n        // and update the areas\n        var p2 = innerPoints[innerPoints.length - 1];\n        for (i = 0; i < innerPoints.length; ++i) {\n            var p1 = innerPoints[i];\n\n            // polygon area updates easily ...\n            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n            // updating the arc area is a little more involved\n            var midPoint = {x : (p1.x + p2.x) / 2,\n                            y : (p1.y + p2.y) / 2},\n                arc = null;\n\n            for (var j = 0; j < p1.parentIndex.length; ++j) {\n                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n                    // figure out the angle halfway between the two points\n                    // on the current circle\n                    var circle = circles[p1.parentIndex[j]],\n                        a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                        a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n                    var angleDiff = (a2 - a1);\n                    if (angleDiff < 0) {\n                        angleDiff += 2*Math.PI;\n                    }\n\n                    // and use that angle to figure out the width of the\n                    // arc\n                    var a = a2 - angleDiff/2,\n                        width = distance(midPoint, {\n                            x : circle.x + circle.radius * Math.sin(a),\n                            y : circle.y + circle.radius * Math.cos(a)\n                        });\n\n                    // clamp the width to the largest is can actually be\n                    // (sometimes slightly overflows because of FP errors)\n                    if (width > circle.radius * 2) {\n                        width = circle.radius * 2;\n                    }\n\n                    // pick the circle whose arc has the smallest width\n                    if ((arc === null) || (arc.width > width)) {\n                        arc = { circle : circle,\n                                width : width,\n                                p1 : p1,\n                                p2 : p2};\n                    }\n                }\n            }\n\n            if (arc !== null) {\n                arcs.push(arc);\n                arcArea += circleArea(arc.circle.radius, arc.width);\n                p2 = p1;\n            }\n        }\n    } else {\n        // no intersection points, is either disjoint - or is completely\n        // overlapped. figure out which by examining the smallest circle\n        var smallest = circles[0];\n        for (i = 1; i < circles.length; ++i) {\n            if (circles[i].radius < smallest.radius) {\n                smallest = circles[i];\n            }\n        }\n\n        // make sure the smallest circle is completely contained in all\n        // the other circles\n        var disjoint = false;\n        for (i = 0; i < circles.length; ++i) {\n            if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n                disjoint = true;\n                break;\n            }\n        }\n\n        if (disjoint) {\n            arcArea = polygonArea = 0;\n\n        } else {\n            arcArea = smallest.radius * smallest.radius * Math.PI;\n            arcs.push({circle : smallest,\n                       p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n                       p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n                       width : smallest.radius * 2 });\n        }\n    }\n\n    polygonArea /= 2;\n    if (stats) {\n        stats.area = arcArea + polygonArea;\n        stats.arcArea = arcArea;\n        stats.polygonArea = polygonArea;\n        stats.arcs = arcs;\n        stats.innerPoints = innerPoints;\n        stats.intersectionPoints = intersectionPoints;\n    }\n\n    return arcArea + polygonArea;\n}\n\n/** returns whether a point is contained by all of a list of circles */\nfunction containedInCircles(point, circles) {\n    for (var i = 0; i < circles.length; ++i) {\n        if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n    var ret = [];\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var intersect = circleCircleIntersection(circles[i],\n                                                          circles[j]);\n            for (var k = 0; k < intersect.length; ++k) {\n                var p = intersect[k];\n                p.parentIndex = [i,j];\n                ret.push(p);\n            }\n        }\n    }\n    return ret;\n}\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nfunction circleArea(r, width) {\n    return r * r * Math.acos(1 - width/r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/** euclidean distance between two points */\nfunction distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                     (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nfunction circleOverlap(r1, r2, d) {\n    // no overlap\n    if (d >= r1 + r2) {\n        return 0;\n    }\n\n    // completely overlapped\n    if (d <= Math.abs(r1 - r2)) {\n        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n    }\n\n    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n    return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\nfunction circleCircleIntersection(p1, p2) {\n    var d = distance(p1, p2),\n        r1 = p1.radius,\n        r2 = p2.radius;\n\n    // if to far away, or self contained - can't be done\n    if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n        return [];\n    }\n\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n        h = Math.sqrt(r1 * r1 - a * a),\n        x0 = p1.x + a * (p2.x - p1.x) / d,\n        y0 = p1.y + a * (p2.y - p1.y) / d,\n        rx = -(p2.y - p1.y) * (h / d),\n        ry = -(p2.x - p1.x) * (h / d);\n\n    return [{x: x0 + rx, y : y0 - ry },\n            {x: x0 - rx, y : y0 + ry }];\n}\n\n/** Returns the center of a bunch of points */\nfunction getCenter(points) {\n    var center = {x: 0, y: 0};\n    for (var i =0; i < points.length; ++i ) {\n        center.x += points[i].x;\n        center.y += points[i].y;\n    }\n    center.x /= points.length;\n    center.y /= points.length;\n    return center;\n}\n\n/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nfunction bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n        throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n        delta /= 2;\n        var mid = a + delta,\n            fMid = f(mid);\n\n        if (fMid * fA >= 0) {\n            a = mid;\n        }\n\n        if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n            return mid;\n        }\n    }\n    return a + delta;\n}\n\n// need some basic operations on vectors, rather than adding a dependency,\n// just define here\nfunction zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\nfunction zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\nfunction dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n        ret += a[i] * b[i];\n    }\n    return ret;\n}\n\nfunction norm2(a)  {\n    return Math.sqrt(dot(a, a));\n}\n\nfunction scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n        ret[i] = value[i] * c;\n    }\n}\n\nfunction weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n        ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n}\n\n/** minimizes a function using the downhill simplex method */\nfunction nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n        chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n        psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n        sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n        maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n        var point = x0.slice();\n        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n        simplex[i+1] = point;\n        simplex[i+1].fx = f(point);\n        simplex[i+1].id = i+1;\n    }\n\n    function updateSimplex(value) {\n        for (var i = 0; i < value.length; i++) {\n            simplex[N][i] = value[i];\n        }\n        simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n        simplex.sort(sortOrder);\n\n        if (parameters.history) {\n            // copy the simplex (since later iterations will mutate) and\n            // sort it to have a consistent order between iterations\n            var sortedSimplex = simplex.map(function (x) {\n                var state = x.slice();\n                state.fx = x.fx;\n                state.id = x.id;\n                return state;\n            });\n            sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n            parameters.history.push({x: simplex[0].slice(),\n                                     fx: simplex[0].fx,\n                                     simplex: sortedSimplex});\n        }\n\n        maxDiff = 0;\n        for (i = 0; i < N; ++i) {\n            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n        }\n\n        if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n            (maxDiff < minTolerance)) {\n            break;\n        }\n\n        // compute the centroid of all but the worst point in the simplex\n        for (i = 0; i < N; ++i) {\n            centroid[i] = 0;\n            for (var j = 0; j < N; ++j) {\n                centroid[i] += simplex[j][i];\n            }\n            centroid[i] /= N;\n        }\n\n        // reflect the worst point past the centroid  and compute loss at reflected\n        // point\n        var worst = simplex[N];\n        weightedSum(reflected, 1+rho, centroid, -rho, worst);\n        reflected.fx = f(reflected);\n\n        // if the reflected point is the best seen, then possibly expand\n        if (reflected.fx < simplex[0].fx) {\n            weightedSum(expanded, 1+chi, centroid, -chi, worst);\n            expanded.fx = f(expanded);\n            if (expanded.fx < reflected.fx) {\n                updateSimplex(expanded);\n            }  else {\n                updateSimplex(reflected);\n            }\n        }\n\n        // if the reflected point is worse than the second worst, we need to\n        // contract\n        else if (reflected.fx >= simplex[N-1].fx) {\n            var shouldReduce = false;\n\n            if (reflected.fx > worst.fx) {\n                // do an inside contraction\n                weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < worst.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            } else {\n                // do an outside contraction\n                weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < reflected.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            }\n\n            if (shouldReduce) {\n                // if we don't contract here, we're done\n                if (sigma >= 1) break;\n\n                // do a reduction\n                for (i = 1; i < simplex.length; ++i) {\n                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                    simplex[i].fx = f(simplex[i]);\n                }\n            }\n        } else {\n            updateSimplex(reflected);\n        }\n    }\n\n    simplex.sort(sortOrder);\n    return {fx : simplex[0].fx,\n            x : simplex[0]};\n}\n\n/// searches along line 'pk' for a point that satifies the wolfe conditions\n/// See 'Numerical Optimization' by Nocedal and Wright p59-60\n/// f : objective function\n/// pk : search direction\n/// current: object containing current gradient/loss\n/// next: output: contains next gradient/loss\n/// returns a: step size taken\nfunction wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0, phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n        for (var iteration = 0; iteration < 16; ++iteration) {\n            a = (a_lo + a_high)/2;\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (phi >= phi_lo)) {\n                a_high = a;\n\n            } else  {\n                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                    return a;\n                }\n\n                if (phiPrime * (a_high - a_lo) >=0) {\n                    a_high = a_lo;\n                }\n\n                a_lo = a;\n                phi_lo = phi;\n            }\n        }\n\n        return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n            (iteration && (phi >= phi_old))) {\n            return zoom(a0, a, phi_old);\n        }\n\n        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n        }\n\n        if (phiPrime >= 0 ) {\n            return zoom(a, a0, phi);\n        }\n\n        phi_old = phi;\n        a0 = a;\n        a *= 2;\n    }\n\n    return a;\n}\n\nfunction conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        yk = initial.slice(),\n        pk, temp,\n        a = 1,\n        maxIterations;\n\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime,-1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n        a = wolfeLineSearch(f, pk, current, next, a);\n\n        // todo: history in wrong spot?\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        if (!a) {\n            // faiiled to find point that satifies wolfe conditions.\n            // reset direction for next iteration\n            scale(pk, current.fxprime, -1);\n\n        } else {\n            // update direction using Polakâ€“Ribiere CG method\n            weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n            var delta_k = dot(current.fxprime, current.fxprime),\n                beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n            weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n            temp = current;\n            current = next;\n            next = temp;\n        }\n\n        if (norm2(current.fxprime) <= 1e-5) {\n            break;\n        }\n    }\n\n    if (params.history) {\n        params.history.push({x: current.x.slice(),\n                             fx: current.fx,\n                             fxprime: current.fxprime.slice(),\n                             alpha: a});\n    }\n\n    return current;\n}\n\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\nfunction venn(areas, parameters) {\n    parameters = parameters || {};\n    parameters.maxIterations = parameters.maxIterations || 500;\n    var initialLayout = parameters.initialLayout || bestInitialLayout;\n    var loss = parameters.lossFunction || lossFunction;\n\n    // add in missing pairwise areas as having 0 size\n    areas = addMissingAreas(areas);\n\n    // initial layout is done greedily\n    var circles = initialLayout(areas, parameters);\n\n    // transform x/y coordinates to a vector to optimize\n    var initial = [], setids = [], setid;\n    for (setid in circles) {\n        if (circles.hasOwnProperty(setid)) {\n            initial.push(circles[setid].x);\n            initial.push(circles[setid].y);\n            setids.push(setid);\n        }\n    }\n\n    // optimize initial layout from our loss function\n    var solution = nelderMead(\n        function(values) {\n            var current = {};\n            for (var i = 0; i < setids.length; ++i) {\n                var setid = setids[i];\n                current[setid] = {x: values[2 * i],\n                                  y: values[2 * i + 1],\n                                  radius : circles[setid].radius,\n                                 // size : circles[setid].size\n                                 };\n            }\n            return loss(current, areas);\n        },\n        initial,\n        parameters);\n\n    // transform solution vector back to x/y points\n    var positions = solution.x;\n    for (var i = 0; i < setids.length; ++i) {\n        setid = setids[i];\n        circles[setid].x = positions[2 * i];\n        circles[setid].y = positions[2 * i + 1];\n    }\n\n    return circles;\n}\n\nvar SMALL$1 = 1e-10;\n\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\nfunction distanceFromIntersectArea(r1, r2, overlap) {\n    // handle complete overlapped circles\n    if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL$1) {\n        return Math.abs(r1 - r2);\n    }\n\n    return bisect(function(distance$$1) {\n        return circleOverlap(r1, r2, distance$$1) - overlap;\n    }, 0, r1 + r2);\n}\n\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\nfunction addMissingAreas(areas) {\n    areas = areas.slice();\n\n    // two circle intersections that aren't defined\n    var ids = [], pairs = {}, i, j, a, b;\n    for (i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            ids.push(area.sets[0]);\n        } else if (area.sets.length == 2) {\n            a = area.sets[0];\n            b = area.sets[1];\n            pairs[[a, b]] = true;\n            pairs[[b, a]] = true;\n        }\n    }\n    ids.sort(function(a, b) { return a > b; });\n\n    for (i = 0; i < ids.length; ++i) {\n        a = ids[i];\n        for (j = i + 1; j < ids.length; ++j) {\n            b = ids[j];\n            if (!([a, b] in pairs)) {\n                areas.push({'sets': [a, b],\n                            'size': 0});\n            }\n        }\n    }\n    return areas;\n}\n\n/// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\nfunction getDistanceMatrices(areas, sets, setids) {\n    // initialize an empty distance matrix between all the points\n    var distances = zerosM(sets.length, sets.length),\n        constraints = zerosM(sets.length, sets.length);\n\n    // compute required distances between all the sets such that\n    // the areas match\n    areas.filter(function(x) { return x.sets.length == 2; })\n        .map(function(current) {\n        var left = setids[current.sets[0]],\n            right = setids[current.sets[1]],\n            r1 = Math.sqrt(sets[left].size / Math.PI),\n            r2 = Math.sqrt(sets[right].size / Math.PI),\n            distance$$1 = distanceFromIntersectArea(r1, r2, current.size);\n\n        distances[left][right] = distances[right][left] = distance$$1;\n\n        // also update constraints to indicate if its a subset or disjoint\n        // relationship\n        var c = 0;\n        if (current.size + 1e-10 >= Math.min(sets[left].size,\n                                             sets[right].size)) {\n            c = 1;\n        } else if (current.size <= 1e-10) {\n            c = -1;\n        }\n        constraints[left][right] = constraints[right][left] = c;\n    });\n\n    return {distances: distances, constraints: constraints};\n}\n\n/// computes the gradient and loss simulatenously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n    var loss = 0, i;\n    for (i = 0; i < fxprime.length; ++i) {\n        fxprime[i] = 0;\n    }\n\n    for (i = 0; i < distances.length; ++i) {\n        var xi = x[2 * i], yi = x[2 * i + 1];\n        for (var j = i + 1; j < distances.length; ++j) {\n            var xj = x[2 * j], yj = x[2 * j + 1],\n                dij = distances[i][j],\n                constraint = constraints[i][j];\n\n            var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n                distance$$1 = Math.sqrt(squaredDistance),\n                delta = squaredDistance - dij * dij;\n\n            if (((constraint > 0) && (distance$$1 <= dij)) ||\n                ((constraint < 0) && (distance$$1 >= dij))) {\n                continue;\n            }\n\n            loss += 2 * delta * delta;\n\n            fxprime[2*i]     += 4 * delta * (xi - xj);\n            fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\n            fxprime[2*j]     += 4 * delta * (xj - xi);\n            fxprime[2*j + 1] += 4 * delta * (yj - yi);\n        }\n    }\n    return loss;\n}\n\n/// takes the best working variant of either constrained MDS or greedy\nfunction bestInitialLayout(areas, params) {\n    var initial = greedyLayout(areas, params);\n    var loss = params.lossFunction || lossFunction;\n\n    // greedylayout is sufficient for all 2/3 circle cases. try out\n    // constrained MDS for higher order problems, take its output\n    // if it outperforms. (greedy is aesthetically better on 2/3 circles\n    // since it axis aligns)\n    if (areas.length >= 8) {\n        var constrained  = constrainedMDSLayout(areas, params),\n            constrainedLoss = loss(constrained, areas),\n            greedyLoss = loss(initial, areas);\n\n        if (constrainedLoss + 1e-8 < greedyLoss) {\n            initial = constrained;\n        }\n    }\n    return initial;\n}\n\n/// use the constrained MDS variant to generate an initial layout\nfunction constrainedMDSLayout(areas, params) {\n    params = params || {};\n    var restarts = params.restarts || 10;\n\n    // bidirectionally map sets to a rowid  (so we can create a matrix)\n    var sets = [], setids = {}, i;\n    for (i = 0; i < areas.length; ++i ) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            setids[area.sets[0]] = sets.length;\n            sets.push(area);\n        }\n    }\n\n    var matrices = getDistanceMatrices(areas, sets, setids),\n        distances = matrices.distances,\n        constraints = matrices.constraints;\n\n    // keep distances bounded, things get messed up otherwise.\n    // TODO: proper preconditioner?\n    var norm = norm2(distances.map(norm2))/(distances.length);\n    distances = distances.map(function (row) {\n        return row.map(function (value) { return value / norm; });});\n\n    var obj = function(x, fxprime) {\n        return constrainedMDSGradient(x, fxprime, distances, constraints);\n    };\n\n    var best, current;\n    for (i = 0; i < restarts; ++i) {\n        var initial = zeros(distances.length*2).map(Math.random);\n\n        current = conjugateGradient(obj, initial, params);\n        if (!best || (current.fx < best.fx)) {\n            best = current;\n        }\n    }\n    var positions = best.x;\n\n    // translate rows back to (x,y,radius) coordinates\n    var circles = {};\n    for (i = 0; i < sets.length; ++i) {\n        var set = sets[i];\n        circles[set.sets[0]] = {\n            x: positions[2*i] * norm,\n            y: positions[2*i + 1] * norm,\n            radius:  Math.sqrt(set.size / Math.PI)\n        };\n    }\n\n    if (params.history) {\n        for (i = 0; i < params.history.length; ++i) {\n            scale(params.history[i].x, norm);\n        }\n    }\n    return circles;\n}\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nfunction greedyLayout(areas, params) {\n    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n    // define a circle for each set\n    var circles = {}, setOverlaps = {}, set;\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            set = area.sets[0];\n            circles[set] = {x: 1e10, y: 1e10,\n                            rowid: circles.length,\n                            size: area.size,\n                            radius: Math.sqrt(area.size / Math.PI)};\n            setOverlaps[set] = [];\n        }\n    }\n    areas = areas.filter(function(a) { return a.sets.length == 2; });\n\n    // map each set to a list of all the other sets that overlap it\n    for (i = 0; i < areas.length; ++i) {\n        var current = areas[i];\n        var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n        var left = current.sets[0], right = current.sets[1];\n\n        // completely overlapped circles shouldn't be positioned early here\n        if (current.size + SMALL$1 >= Math.min(circles[left].size,\n                                             circles[right].size)) {\n            weight = 0;\n        }\n\n        setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n        setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n    }\n\n    // get list of most overlapped sets\n    var mostOverlapped = [];\n    for (set in setOverlaps) {\n        if (setOverlaps.hasOwnProperty(set)) {\n            var size = 0;\n            for (i = 0; i < setOverlaps[set].length; ++i) {\n                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n            }\n\n            mostOverlapped.push({set: set, size:size});\n        }\n    }\n\n    // sort by size desc\n    function sortOrder(a,b) {\n        return b.size - a.size;\n    }\n    mostOverlapped.sort(sortOrder);\n\n    // keep track of what sets have been laid out\n    var positioned = {};\n    function isPositioned(element) {\n        return element.set in positioned;\n    }\n\n    // adds a point to the output\n    function positionSet(point, index) {\n        circles[index].x = point.x;\n        circles[index].y = point.y;\n        positioned[index] = true;\n    }\n\n    // add most overlapped set at (0,0)\n    positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\n    // get distances between all points. TODO, necessary?\n    // answer: probably not\n    // var distances = venn.getDistanceMatrices(circles, areas).distances;\n    for (i = 1; i < mostOverlapped.length; ++i) {\n        var setIndex = mostOverlapped[i].set,\n            overlap = setOverlaps[setIndex].filter(isPositioned);\n        set = circles[setIndex];\n        overlap.sort(sortOrder);\n\n        if (overlap.length === 0) {\n            // this shouldn't happen anymore with addMissingAreas\n            throw \"ERROR: missing pairwise overlap information\";\n        }\n\n        var points = [];\n        for (var j = 0; j < overlap.length; ++j) {\n            // get appropriate distance from most overlapped already added set\n            var p1 = circles[overlap[j].set],\n                d1 = distanceFromIntersectArea(set.radius, p1.radius,\n                                               overlap[j].size);\n\n            // sample positions at 90 degrees for maximum aesthetics\n            points.push({x : p1.x + d1, y : p1.y});\n            points.push({x : p1.x - d1, y : p1.y});\n            points.push({y : p1.y + d1, x : p1.x});\n            points.push({y : p1.y - d1, x : p1.x});\n\n            // if we have at least 2 overlaps, then figure out where the\n            // set should be positioned analytically and try those too\n            for (var k = j + 1; k < overlap.length; ++k) {\n                var p2 = circles[overlap[k].set],\n                    d2 = distanceFromIntersectArea(set.radius, p2.radius,\n                                                   overlap[k].size);\n\n                var extraPoints = circleCircleIntersection(\n                    { x: p1.x, y: p1.y, radius: d1},\n                    { x: p2.x, y: p2.y, radius: d2});\n\n                for (var l = 0; l < extraPoints.length; ++l) {\n                    points.push(extraPoints[l]);\n                }\n            }\n        }\n\n        // we have some candidate positions for the set, examine loss\n        // at each position to figure out where to put it at\n        var bestLoss = 1e50, bestPoint = points[0];\n        for (j = 0; j < points.length; ++j) {\n            circles[setIndex].x = points[j].x;\n            circles[setIndex].y = points[j].y;\n            var localLoss = loss(circles, areas);\n            if (localLoss < bestLoss) {\n                bestLoss = localLoss;\n                bestPoint = points[j];\n            }\n        }\n\n        positionSet(bestPoint, setIndex);\n    }\n\n    return circles;\n}\n\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\nfunction lossFunction(sets, overlaps) {\n    var output = 0;\n\n    function getCircles(indices) {\n        return indices.map(function(i) { return sets[i]; });\n    }\n\n    for (var i = 0; i < overlaps.length; ++i) {\n        var area = overlaps[i], overlap;\n        if (area.sets.length == 1) {\n            continue;\n        } else if (area.sets.length == 2) {\n            var left = sets[area.sets[0]],\n                right = sets[area.sets[1]];\n            overlap = circleOverlap(left.radius, right.radius,\n                                    distance(left, right));\n        } else {\n            overlap = intersectionArea(getCircles(area.sets));\n        }\n\n        var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n        output += weight * (overlap - area.size) * (overlap - area.size);\n    }\n\n    return output;\n}\n\n// orientates a bunch of circles to point in orientation\nfunction orientateCircles(circles, orientation, orientationOrder) {\n    if (orientationOrder === null) {\n        circles.sort(function (a, b) { return b.radius - a.radius; });\n    } else {\n        circles.sort(orientationOrder);\n    }\n\n    var i;\n    // shift circles so largest circle is at (0, 0)\n    if (circles.length > 0) {\n        var largestX = circles[0].x,\n            largestY = circles[0].y;\n\n        for (i = 0; i < circles.length; ++i) {\n            circles[i].x -= largestX;\n            circles[i].y -= largestY;\n        }\n    }\n\n    if (circles.length == 2) {\n        // if the second circle is a subset of the first, arrange so that\n        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n        var dist = distance(circles[0], circles[1]);\n        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n            circles[1].y = circles[0].y;\n        }\n    }\n\n    // rotate circles so that second largest is at an angle of 'orientation'\n    // from largest\n    if (circles.length > 1) {\n        var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n            c = Math.cos(rotation),\n            s = Math.sin(rotation), x, y;\n\n        for (i = 0; i < circles.length; ++i) {\n            x = circles[i].x;\n            y = circles[i].y;\n            circles[i].x = c * x - s * y;\n            circles[i].y = s * x + c * y;\n        }\n    }\n\n    // mirror solution if third solution is above plane specified by\n    // first two circles\n    if (circles.length > 2) {\n        var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n        while (angle < 0) { angle += 2* Math.PI; }\n        while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n        if (angle > Math.PI) {\n            var slope = circles[1].y / (1e-10 + circles[1].x);\n            for (i = 0; i < circles.length; ++i) {\n                var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n                circles[i].x = 2 * d - circles[i].x;\n                circles[i].y = 2 * d * slope - circles[i].y;\n            }\n        }\n    }\n}\n\nfunction disjointCluster(circles) {\n    // union-find clustering to get disjoint sets\n    circles.map(function(circle) { circle.parent = circle; });\n\n    // path compression step in union find\n    function find(circle) {\n        if (circle.parent !== circle) {\n            circle.parent = find(circle.parent);\n        }\n        return circle.parent;\n    }\n\n    function union(x, y) {\n        var xRoot = find(x), yRoot = find(y);\n        xRoot.parent = yRoot;\n    }\n\n    // get the union of all overlapping sets\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var maxDistance = circles[i].radius + circles[j].radius;\n            if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n                union(circles[j], circles[i]);\n            }\n        }\n    }\n\n    // find all the disjoint clusters and group them together\n    var disjointClusters = {}, setid;\n    for (i = 0; i < circles.length; ++i) {\n        setid = find(circles[i]).parent.setid;\n        if (!(setid in disjointClusters)) {\n            disjointClusters[setid] = [];\n        }\n        disjointClusters[setid].push(circles[i]);\n    }\n\n    // cleanup bookkeeping\n    circles.map(function(circle) { delete circle.parent; });\n\n    // return in more usable form\n    var ret = [];\n    for (setid in disjointClusters) {\n        if (disjointClusters.hasOwnProperty(setid)) {\n            ret.push(disjointClusters[setid]);\n        }\n    }\n    return ret;\n}\n\nfunction getBoundingBox(circles) {\n    var minMax = function(d) {\n        var hi = Math.max.apply(null, circles.map(\n                                function(c) { return c[d] + c.radius; } )),\n            lo = Math.min.apply(null, circles.map(\n                                function(c) { return c[d] - c.radius;} ));\n        return {max:hi, min:lo};\n    };\n\n    return {xRange: minMax('x'), yRange: minMax('y')};\n}\n\nfunction normalizeSolution(solution, orientation, orientationOrder) {\n    if (orientation === null){\n        orientation = Math.PI/2;\n    }\n\n    // work with a list instead of a dictionary, and take a copy so we\n    // don't mutate input\n    var circles = [], i, setid;\n    for (setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            var previous = solution[setid];\n            circles.push({x: previous.x,\n                          y: previous.y,\n                          radius: previous.radius,\n                          setid: setid});\n        }\n    }\n\n    // get all the disjoint clusters\n    var clusters = disjointCluster(circles);\n\n    // orientate all disjoint sets, get sizes\n    for (i = 0; i < clusters.length; ++i) {\n        orientateCircles(clusters[i], orientation, orientationOrder);\n        var bounds = getBoundingBox(clusters[i]);\n        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n        clusters[i].bounds = bounds;\n    }\n    clusters.sort(function(a, b) { return b.size - a.size; });\n\n    // orientate the largest at 0,0, and get the bounds\n    circles = clusters[0];\n    var returnBounds = circles.bounds;\n\n    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\n    function addCluster(cluster, right, bottom) {\n        if (!cluster) return;\n\n        var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\n        if (right) {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n        } else {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n                        (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n            if (centreing < 0) xOffset += centreing;\n        }\n\n        if (bottom) {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n        } else {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n                        (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n            if (centreing < 0) yOffset += centreing;\n        }\n\n        for (var j = 0; j < cluster.length; ++j) {\n            cluster[j].x += xOffset;\n            cluster[j].y += yOffset;\n            circles.push(cluster[j]);\n        }\n    }\n\n    var index = 1;\n    while (index < clusters.length) {\n        addCluster(clusters[index], true, false);\n        addCluster(clusters[index+1], false, true);\n        addCluster(clusters[index+2], true, true);\n        index += 3;\n\n        // have one cluster (in top left). lay out next three relative\n        // to it in a grid\n        returnBounds = getBoundingBox(circles);\n    }\n\n    // convert back to solution form\n    var ret = {};\n    for (i = 0; i < circles.length; ++i) {\n        ret[circles[i].setid] = circles[i];\n    }\n    return ret;\n}\n\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\nfunction scaleSolution(solution, width, height, padding) {\n    var circles = [], setids = [];\n    for (var setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            setids.push(setid);\n            circles.push(solution[setid]);\n        }\n    }\n\n    width -= 2*padding;\n    height -= 2*padding;\n\n    var bounds = getBoundingBox(circles),\n        xRange = bounds.xRange,\n        yRange = bounds.yRange;\n\n    if ((xRange.max == xRange.min) ||\n        (yRange.max == yRange.min)) {\n        console.log(\"not scaling solution: zero size detected\");\n        return solution;\n    }\n\n    var xScaling = width  / (xRange.max - xRange.min),\n        yScaling = height / (yRange.max - yRange.min),\n        scaling = Math.min(yScaling, xScaling),\n\n        // while we're at it, center the diagram too\n        xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n        yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n    var scaled = {};\n    for (var i = 0; i < circles.length; ++i) {\n        var circle = circles[i];\n        scaled[setids[i]] = {\n            radius: scaling * circle.radius,\n            x: padding + xOffset + (circle.x - xRange.min) * scaling,\n            y: padding + yOffset + (circle.y - yRange.min) * scaling,\n        };\n    }\n\n    return scaled;\n}\n\n/*global console:true*/\n\nfunction VennDiagram() {\n    var width = 600,\n        height = 350,\n        padding = 15,\n        duration = 1000,\n        orientation = Math.PI / 2,\n        normalize = true,\n        wrap = true,\n        styled = true,\n        fontSize = null,\n        orientationOrder = null,\n\n        // mimic the behaviour of d3.scale.category10 from the previous\n        // version of d3\n        colourMap = {},\n\n        // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n        // since we can support older versions of d3 as long as we don't force this,\n        // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n        colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n        colourIndex = 0,\n        colours = function(key) {\n            if (key in colourMap) {\n                return colourMap[key];\n            }\n            var ret = colourMap[key] = colourScheme[colourIndex];\n            colourIndex += 1;\n            if (colourIndex >= colourScheme.length) {\n                colourIndex = 0;\n            }\n            return ret;\n        },\n        layoutFunction = venn,\n        loss = lossFunction;\n\n\n    function chart(selection) {\n        var data = selection.datum();\n\n        // handle 0-sized sets by removing from input\n        var toremove = {};\n        data.forEach(function(datum) {\n            if ((datum.size == 0) && datum.sets.length == 1) {\n                toremove[datum.sets[0]] = 1;\n            }\n        });\n        data = data.filter(function(datum) {\n            return !datum.sets.some(function(set) { return set in toremove; });\n        });\n\n        var circles = {};\n        var textCentres = {};\n\n        if (data.length > 0) {\n            var solution = layoutFunction(data, {lossFunction: loss});\n\n            if (normalize) {\n                solution = normalizeSolution(solution,\n                                            orientation,\n                                            orientationOrder);\n            }\n\n            circles = scaleSolution(solution, width, height, padding);\n            textCentres = computeTextCentres(circles, data);\n        }\n\n        // Figure out the current label for each set. These can change\n        // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n        var labels = {};\n        data.forEach(function(datum) {\n            if (datum.label) {\n                labels[datum.sets] = datum.label;\n            }\n        });\n\n        function label(d) {\n            if (d.sets in labels) {\n                return labels[d.sets];\n            }\n            if (d.sets.length == 1) {\n                return '' + d.sets[0];\n            }\n        }\n\n        // create svg if not already existing\n        selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\n        var svg = selection.select(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        // to properly transition intersection areas, we need the\n        // previous circles locations. load from elements\n        var previous = {}, hasPrevious = false;\n        svg.selectAll(\".venn-area path\").each(function (d) {\n            var path = d3Selection.select(this).attr(\"d\");\n            if ((d.sets.length == 1) && path) {\n                hasPrevious = true;\n                previous[d.sets[0]] = circleFromPath(path);\n            }\n        });\n\n        // interpolate intersection area paths between previous and\n        // current paths\n        var pathTween = function(d) {\n            return function(t) {\n                var c = d.sets.map(function(set) {\n                    var start = previous[set], end = circles[set];\n                    if (!start) {\n                        start = {x : width/2, y : height/2, radius : 1};\n                    }\n                    if (!end) {\n                        end = {x : width/2, y : height/2, radius : 1};\n                    }\n                    return {'x' : start.x * (1 - t) + end.x * t,\n                            'y' : start.y * (1 - t) + end.y * t,\n                            'radius' : start.radius * (1 - t) + end.radius * t};\n                });\n                return intersectionAreaPath(c);\n            };\n        };\n\n        // update data, joining on the set ids\n        var nodes = svg.selectAll(\".venn-area\")\n            .data(data, function(d) { return d.sets; });\n\n        // create new nodes\n        var enter = nodes.enter()\n            .append('g')\n            .attr(\"class\", function(d) {\n                return \"venn-area venn-\" +\n                    (d.sets.length == 1 ? \"circle\" : \"intersection\");\n            })\n            .attr(\"data-venn-sets\", function(d) {\n                return d.sets.join(\"_\");\n            });\n\n        var enterPath = enter.append(\"path\"),\n            enterText = enter.append(\"text\")\n            .attr(\"class\", \"label\")\n            .text(function (d) { return label(d); } )\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"dy\", \".35em\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n\n        // apply minimal style if wanted\n        if (styled) {\n            enterPath.style(\"fill-opacity\", \"0\")\n                .filter(function (d) { return d.sets.length == 1; } )\n                .style(\"fill\", function(d) { return colours(d.sets); })\n                .style(\"fill-opacity\", \".25\");\n\n            enterText\n                .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(d.sets) : \"#444\"; });\n        }\n\n        // update existing, using pathTween if necessary\n        var update = selection;\n        if (hasPrevious) {\n            update = selection.transition(\"venn\").duration(duration);\n            update.selectAll(\"path\")\n                .attrTween(\"d\", pathTween);\n        } else {\n            update.selectAll(\"path\")\n                .attr(\"d\", function(d) {\n                    return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n                });\n        }\n\n        var updateText = update.selectAll(\"text\")\n            .filter(function (d) { return d.sets in textCentres; })\n            .text(function (d) { return label(d); } )\n            .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n            .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\n        if (wrap) {\n            if (hasPrevious) {\n                // d3 4.0 uses 'on' for events on transitions,\n                // but d3 3.0 used 'each' instead. switch appropiately\n                if ('on' in updateText) {\n                    updateText.on(\"end\", wrapText(circles, label));\n                } else {\n                    updateText.each(\"end\", wrapText(circles, label));\n                }\n            } else {\n                updateText.each(wrapText(circles, label));\n            }\n        }\n\n        // remove old\n        var exit = nodes.exit().transition('venn').duration(duration).remove();\n        exit.selectAll(\"path\")\n            .attrTween(\"d\", pathTween);\n\n        var exitText = exit.selectAll(\"text\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n        // if we've been passed a fontSize explicitly, use it to\n        // transition\n        if (fontSize !== null) {\n            enterText.style(\"font-size\", \"0px\");\n            updateText.style(\"font-size\", fontSize);\n            exitText.style(\"font-size\", \"0px\");\n        }\n\n\n        return {'circles': circles,\n                'textCentres': textCentres,\n                'nodes': nodes,\n                'enter': enter,\n                'update': update,\n                'exit': exit};\n    }\n\n    chart.wrap = function(_) {\n        if (!arguments.length) return wrap;\n        wrap = _;\n        return chart;\n    };\n\n    chart.width = function(_) {\n        if (!arguments.length) return width;\n        width = _;\n        return chart;\n    };\n\n    chart.height = function(_) {\n        if (!arguments.length) return height;\n        height = _;\n        return chart;\n    };\n\n    chart.padding = function(_) {\n        if (!arguments.length) return padding;\n        padding = _;\n        return chart;\n    };\n\n    chart.colours = function(_) {\n        if (!arguments.length) return colours;\n        colours = _;\n        return chart;\n    };\n\n    chart.fontSize = function(_) {\n        if (!arguments.length) return fontSize;\n        fontSize = _;\n        return chart;\n    };\n\n    chart.duration = function(_) {\n        if (!arguments.length) return duration;\n        duration = _;\n        return chart;\n    };\n\n    chart.layoutFunction = function(_) {\n        if (!arguments.length) return layoutFunction;\n        layoutFunction = _;\n        return chart;\n    };\n\n    chart.normalize = function(_) {\n        if (!arguments.length) return normalize;\n        normalize = _;\n        return chart;\n    };\n\n    chart.styled = function(_) {\n        if (!arguments.length) return styled;\n        styled = _;\n        return chart;\n    };\n\n    chart.orientation = function(_) {\n        if (!arguments.length) return orientation;\n        orientation = _;\n        return chart;\n    };\n\n    chart.orientationOrder = function(_) {\n        if (!arguments.length) return orientationOrder;\n        orientationOrder = _;\n        return chart;\n    };\n\n    chart.lossFunction = function(_) {\n      if (!arguments.length) return loss;\n      loss = _;\n      return chart;\n    };\n\n    return chart;\n}\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nfunction wrapText(circles, labeller) {\n    return function() {\n        var text = d3Selection.select(this),\n            data = text.datum(),\n            width = circles[data.sets[0]].radius || 50,\n            label = labeller(data) || '';\n\n            var words = label.split(/\\s+/).reverse(),\n            maxLines = 3,\n            minChars = (label.length + words.length) / maxLines,\n            word = words.pop(),\n            line = [word],\n            joined,\n            lineNumber = 0,\n            lineHeight = 1.1, // ems\n            tspan = text.text(null).append(\"tspan\").text(word);\n\n        while (true) {\n            word = words.pop();\n            if (!word) break;\n            line.push(word);\n            joined = line.join(\" \");\n            tspan.text(joined);\n            if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n                line.pop();\n                tspan.text(line.join(\" \"));\n                line = [word];\n                tspan = text.append(\"tspan\").text(word);\n                lineNumber++;\n            }\n        }\n\n        var initial = 0.35 - lineNumber * lineHeight / 2,\n            x = text.attr(\"x\"),\n            y = text.attr(\"y\");\n\n        text.selectAll(\"tspan\")\n            .attr(\"x\", x)\n            .attr(\"y\", y)\n            .attr(\"dy\", function(d, i) {\n                 return (initial + i * lineHeight) + \"em\";\n            });\n    };\n}\n\nfunction circleMargin(current, interior, exterior) {\n    var margin = interior[0].radius - distance(interior[0], current), i, m;\n    for (i = 1; i < interior.length; ++i) {\n        m = interior[i].radius - distance(interior[i], current);\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        m = distance(exterior[i], current) - exterior[i].radius;\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n    return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nfunction computeTextCentre(interior, exterior) {\n    // get an initial estimate by sampling around the interior circles\n    // and taking the point with the biggest margin\n    var points = [], i;\n    for (i = 0; i < interior.length; ++i) {\n        var c = interior[i];\n        points.push({x: c.x, y: c.y});\n        points.push({x: c.x + c.radius/2, y: c.y});\n        points.push({x: c.x - c.radius/2, y: c.y});\n        points.push({x: c.x, y: c.y + c.radius/2});\n        points.push({x: c.x, y: c.y - c.radius/2});\n    }\n    var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n    for (i = 1; i < points.length; ++i) {\n        var m = circleMargin(points[i], interior, exterior);\n        if (m >= margin) {\n            initial = points[i];\n            margin = m;\n        }\n    }\n\n    // maximize the margin numerically\n    var solution = nelderMead(\n                function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n                [initial.x, initial.y],\n                {maxIterations:500, minErrorDelta:1e-10}).x;\n    var ret = {x: solution[0], y: solution[1]};\n\n    // check solution, fallback as needed (happens if fully overlapped\n    // etc)\n    var valid = true;\n    for (i = 0; i < interior.length; ++i) {\n        if (distance(ret, interior[i]) > interior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        if (distance(ret, exterior[i]) < exterior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    if (!valid) {\n        if (interior.length == 1) {\n            ret = {x: interior[0].x, y: interior[0].y};\n        } else {\n            var areaStats = {};\n            intersectionArea(interior, areaStats);\n\n            if (areaStats.arcs.length === 0) {\n                ret = {'x': 0, 'y': -1000, disjoint:true};\n\n            } else if (areaStats.arcs.length == 1) {\n                ret = {'x': areaStats.arcs[0].circle.x,\n                       'y': areaStats.arcs[0].circle.y};\n\n            } else if (exterior.length) {\n                // try again without other circles\n                ret = computeTextCentre(interior, []);\n\n            } else {\n                // take average of all the points in the intersection\n                // polygon. this should basically never happen\n                // and has some issues:\n                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n                ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n            }\n        }\n    }\n\n    return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n    var ret = {}, circleids = [];\n    for (var circleid in circles) {\n        circleids.push(circleid);\n        ret[circleid] = [];\n    }\n    for (var i  = 0; i < circleids.length; i++) {\n        var a = circles[circleids[i]];\n        for (var j = i + 1; j < circleids.length; ++j) {\n            var b = circles[circleids[j]],\n                d = distance(a, b);\n\n            if (d + b.radius <= a.radius + 1e-10) {\n                ret[circleids[j]].push(circleids[i]);\n\n            } else if (d + a.radius <= b.radius + 1e-10) {\n                ret[circleids[i]].push(circleids[j]);\n            }\n        }\n    }\n    return ret;\n}\n\nfunction computeTextCentres(circles, areas) {\n    var ret = {}, overlapped = getOverlappingCircles(circles);\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i].sets, areaids = {}, exclude = {};\n        for (var j = 0; j < area.length; ++j) {\n            areaids[area[j]] = true;\n            var overlaps = overlapped[area[j]];\n            // keep track of any circles that overlap this area,\n            // and don't consider for purposes of computing the text\n            // centre\n            for (var k = 0; k < overlaps.length; ++k) {\n                exclude[overlaps[k]] = true;\n            }\n        }\n\n        var interior = [], exterior = [];\n        for (var setid in circles) {\n            if (setid in areaids) {\n                interior.push(circles[setid]);\n            } else if (!(setid in exclude)) {\n                exterior.push(circles[setid]);\n            }\n        }\n        var centre = computeTextCentre(interior, exterior);\n        ret[area] = centre;\n        if (centre.disjoint && (areas[i].size > 0)) {\n            console.log(\"WARNING: area \" + area + \" not represented on screen\");\n        }\n    }\n    return  ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nfunction sortAreas(div, relativeTo) {\n\n    // figure out sets that are completly overlapped by relativeTo\n    var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n    var exclude = {};\n    for (var i = 0; i < relativeTo.sets.length; ++i) {\n        var check = relativeTo.sets[i];\n        for (var setid in overlaps) {\n            var overlap = overlaps[setid];\n            for (var j = 0; j < overlap.length; ++j) {\n                if (overlap[j] == check) {\n                    exclude[setid] = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    // checks that all sets are in exclude;\n    function shouldExclude(sets) {\n        for (var i = 0; i < sets.length; ++i) {\n            if (!(sets[i] in exclude)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // need to sort div's so that Z order is correct\n    div.selectAll(\"g\").sort(function (a, b) {\n        // highest order set intersections first\n        if (a.sets.length != b.sets.length) {\n            return a.sets.length - b.sets.length;\n        }\n\n        if (a == relativeTo) {\n            return shouldExclude(b.sets) ? -1 : 1;\n        }\n        if (b == relativeTo) {\n            return shouldExclude(a.sets) ? 1 : -1;\n        }\n\n        // finally by size\n        return b.size - a.size;\n    });\n}\n\nfunction circlePath(x, y, r) {\n    var ret = [];\n    ret.push(\"\\nM\", x, y);\n    ret.push(\"\\nm\", -r, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n    return ret.join(\" \");\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nfunction circleFromPath(path) {\n    var tokens = path.split(' ');\n    return {'x' : parseFloat(tokens[1]),\n            'y' : parseFloat(tokens[2]),\n            'radius' : -parseFloat(tokens[4])\n            };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nfunction intersectionAreaPath(circles) {\n    var stats = {};\n    intersectionArea(circles, stats);\n    var arcs = stats.arcs;\n\n    if (arcs.length === 0) {\n        return \"M 0 0\";\n\n    } else if (arcs.length == 1) {\n        var circle = arcs[0].circle;\n        return circlePath(circle.x, circle.y, circle.radius);\n\n    } else {\n        // draw path around arcs\n        var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n        for (var i = 0; i < arcs.length; ++i) {\n            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n            ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n                     arc.p1.x, arc.p1.y);\n        }\n        return ret.join(\" \");\n    }\n}\n\nexports.intersectionArea = intersectionArea;\nexports.circleCircleIntersection = circleCircleIntersection;\nexports.circleOverlap = circleOverlap;\nexports.circleArea = circleArea;\nexports.distance = distance;\nexports.venn = venn;\nexports.greedyLayout = greedyLayout;\nexports.scaleSolution = scaleSolution;\nexports.normalizeSolution = normalizeSolution;\nexports.bestInitialLayout = bestInitialLayout;\nexports.lossFunction = lossFunction;\nexports.disjointCluster = disjointCluster;\nexports.distanceFromIntersectArea = distanceFromIntersectArea;\nexports.VennDiagram = VennDiagram;\nexports.wrapText = wrapText;\nexports.computeTextCentres = computeTextCentres;\nexports.computeTextCentre = computeTextCentre;\nexports.sortAreas = sortAreas;\nexports.circlePath = circlePath;\nexports.circleFromPath = circleFromPath;\nexports.intersectionAreaPath = intersectionAreaPath;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}